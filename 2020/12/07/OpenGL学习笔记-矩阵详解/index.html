<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="referrer" content="origin">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>OpenGL学习笔记-矩阵详解</title>

    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/LongCang.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/Monda.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/NotoSansSC.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/Playball.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/PTMono.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/RobotoSlab.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/Rosario.css">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/UbuntuMono.css">

    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/post.css">
    
        <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/normal.css">
    

    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/jquery-3.4.1.min.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Oh My God" type="application/atom+xml">
</head>
<body>

    
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
      </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



    <a id="cover"></a>
    <div id="header">
    <div class="header">
        <div class="vertical">
            <div class="inner">
                <h1 class="header-subtitle">OpenGL学习笔记-矩阵详解</h1>
                <div class="header-subinfo">
                    <p class="article-info-text">
                        <span>
                            <i class="iconfont icon-time"></i> 发表时间：2020-12-07
                        </span>
                        
                            <span id="/2020/12/07/OpenGL学习笔记-矩阵详解/" class="leancloud_visitors" data-flag-title="OpenGL学习笔记-矩阵详解">
                                <i class="iconfont icon-browse"></i> 阅读：<sapn class="leancloud-visitors-count"></span>
                            </span>
                        
                        <span>
                            <i class="iconfont icon-interactive"></i> 评论：<span class="valine-comment-count" data-xid="/2020/12/07/OpenGL学习笔记-矩阵详解/"></span>
                        </span>  
                    </p>                 
                </div>
            </div>
        </div>
        <canvas id="articleHeaderCanvas"></canvas>
    </div>
</div>
    <div id="container">
    <div id="content">
        <div id="article">
    <div class="toc"></div>

    <div class="article-body">
        <h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul>
<li>opengl教程—<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统</a></li>
<li>opengl教程—<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">变换</a></li>
<li>观察矩阵搬移来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangdingqiaoit/article/details/51570001">这里</a></li>
<li>视角部分搬移来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/Jaihk662/article/details/106519595">这里</a></li>
<li>投影矩阵搬移来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/wangdingqiaoit/article/details/51589825?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control">这里</a></li>
<li>songho<a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_projectionmatrix.html"> OpenGL Projection Matrix</a></li>
</ul>
<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>OpenGL最终的渲染设备是2D的，我们需要将3D表示的场景转换为最终的2D形式，前面使用模型变换和视变换将物体坐标转换到照相机坐标系后，需要进行投影变换，将坐标从相机—&gt;裁剪坐标系，经过透视除法后，变换到规范化设备坐标系(NDC)，最后进行视口变换后，3D坐标才变换到屏幕上的2D坐标，这个过程如下图所示：</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/1.png)

</center>

<p>其中比较关键的就是以下，</p>
<ul>
<li>模型矩阵：将物体从局部坐标变换到世界空间坐标</li>
<li>观察矩阵：将物体从世界坐标变换到观察坐标</li>
<li>投影矩阵：加上后续自动执行的透视除法将观察坐标变换成标准设备坐标</li>
<li>视口变换矩阵：将NDC坐标转换为显示屏幕坐标</li>
</ul>
<script type="math/tex; mode=display">
V_{screen2D} = M_{viewPort} \cdot M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}</script><p>由此完成了从局部的一个3D的点变到2D屏幕上的过程。</p>
<p>看到这里对各个矩阵还是比较迷糊，所以找来了教程从数学的角度来让我们看看各个矩阵背后到底是怎样的。</p>
<h1 id="模型矩阵"><a href="#模型矩阵" class="headerlink" title="模型矩阵"></a>模型矩阵</h1><p>我们在OpenGL中通过定义一组顶点来定义一个模型，或者通过其他3D建模软件事先建好模型然后导入到OpenGL中。顶点属性定义了模型。如果我们要在一个场景中不同位置显示同一个模型怎么办？ 如果我们要以不同的比例、不同角度显示同一个模型又怎么办 ？</p>
<p>如果继续以类似的顶点属性数据定义同一个模型，调整它满足上述需求的话，不仅浪费显卡内存，而且这个调整的工作量也很大，因此效率很低。更好地解决方法是，我们定义的模型根据需要可以执行放大、缩小等操作来不同比例显示，可以通过平移来放在不同位置，可以通过旋转来按不同角度显示。这种方式就是执行模型变换。</p>
<p>模型变换通过对模型执行平移(translation)、缩放(scale)、旋转(rotation)、镜像(reflection)、错切(shear)等操作，来调整模型的过程。通过模型变换，我们可以按照合理方式指定场景中物体的位置等信息。</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/2.png)

</center>


<p>这部分不是很困难，相关的矩阵如下：</p>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>假设缩放向量表示为$\left ( S_1, S_2,S_3 \right )$:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
S_1 & 0 & 0 & 0\\ 
0 &  S_2& 0 & 0\\ 
0 &  0&  S_3&0 \\ 
 0& 0 &0  & 1
\end{bmatrix} 
\cdot 
\begin{bmatrix}
x\\ 
y\\ 
z\\ 
1
\end{bmatrix} = \begin{bmatrix}
S_1 \cdot x\\ 
S_2 \cdot y\\ 
S_3 \cdot z\\ 
1
\end{bmatrix}</script><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>假设位移向量表示为$\left ( T_x, T_y,T_z \right )$:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 & 0 & T_x\\ 
0 &  1& 0 & T_y\\ 
0 &  0&  1&T_z \\ 
 0& 0 &0  & 1
\end{bmatrix} 
\cdot 
\begin{bmatrix}
x\\ 
y\\ 
z\\ 
1
\end{bmatrix} = \begin{bmatrix}
x + T_x\\ 
y + T_y\\ 
z + T_z\\ 
1
\end{bmatrix}</script><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><h3 id="沿x轴旋转："><a href="#沿x轴旋转：" class="headerlink" title="沿x轴旋转："></a>沿x轴旋转：</h3><script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 & 0 & 0\\ 
0 &  cos\theta& -sin\theta & 0\\ 
0 &  sin\theta&  cos\theta&0 \\ 
 0& 0 &0  & 1
\end{bmatrix}  
\cdot
 \begin{bmatrix}
x\\ 
y\\ 
z\\ 
1
\end{bmatrix}  = \begin{bmatrix}
x\\ 
cos\theta \cdot y - sin\theta \cdot z\\ 
sin\theta \cdot y + cos\theta \cdot z\\ 
1
\end{bmatrix}</script><h3 id="沿y轴旋转："><a href="#沿y轴旋转：" class="headerlink" title="沿y轴旋转："></a>沿y轴旋转：</h3><script type="math/tex; mode=display">
\begin{bmatrix}
cos\theta &0 & sin\theta  & 0\\ 
0 &  1& 0 & 0\\ 
-sin\theta & 0 & cos\theta&0 \\ 
 0& 0 &0  & 1
\end{bmatrix} 
\cdot 
\begin{bmatrix}
x\\ 
y\\ 
z\\ 
1
\end{bmatrix} = \begin{bmatrix}
cos\theta \cdot x + sin\theta \cdot z\\ 
y\\ 
-sin\theta \cdot x + cos\theta \cdot z\\ 
1
\end{bmatrix}</script><h3 id="沿z轴旋转："><a href="#沿z轴旋转：" class="headerlink" title="沿z轴旋转："></a>沿z轴旋转：</h3><script type="math/tex; mode=display">
\begin{bmatrix}
cos\theta & -sin\theta & 0 & 0\\ 
sin\theta &  cos\theta& 0 & 0\\ 
0 &  0& 1&0 \\ 
 0& 0 &0  & 1
\end{bmatrix} 
\cdot 
\begin{bmatrix}
x\\ 
y\\ 
z\\ 
1
\end{bmatrix} = \begin{bmatrix}
cos\theta \cdot x - sin\theta \cdot y\\ 
sin\theta \cdot x + cos\theta \cdot y\\ 
z\\ 
1
\end{bmatrix}</script><h3 id="沿任意轴旋转："><a href="#沿任意轴旋转：" class="headerlink" title="沿任意轴旋转："></a>沿任意轴旋转：</h3><p>其中$\left ( R_x, R_y,R_z \right )$代表任意旋转轴：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
cos\theta + {R_x}^2(1-cos\theta)) & R_xR_y(1-cos\theta)-R_zsin\theta  & R_xR_z(1-cos\theta)+R_ysin\theta & 0\\ 
R_yR_x(1-cos\theta)+R_zsin\theta &  cos\theta + {R_y}^2(1-cos\theta)& R_yR_z(1-cos\theta)-R_xsin\theta & 0\\ 
R_zR_x(1-cos\theta)-R_ysin\theta &  R_zR_y(1-cos\theta)+R_xsin\theta& cos\theta + {R_z}^2(1-cos\theta)&0 \\ 
 0& 0 &0  & 1
\end{bmatrix}</script><h2 id="矩阵的组合"><a href="#矩阵的组合" class="headerlink" title="矩阵的组合"></a>矩阵的组合</h2><p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该<code>从右向左</code>读这个乘法。建议您在组合矩阵时，<strong>先进行缩放操作，然后是旋转，最后才是位移</strong>，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！在实际中多半是这些变换的组合，一般地执行变换顺序为<code>缩放–&gt;旋转—&gt;平移</code>。在实行模型变换时，要注意变换的顺序和代码中书写的顺序相反。同时对于缩放和旋转变换，要注意不动点不在原点时的处理方法(先把物体的中心移到原点，然后应用旋转矩阵，最后再把物体移回到原处)。</p>
<h1 id="观察矩阵"><a href="#观察矩阵" class="headerlink" title="观察矩阵"></a>观察矩阵</h1><p>OpenGL成像采用的是虚拟相机模型。在场景中你通过模型变换，将物体放在场景中不同位置后，最终哪些部分需要成像，显示在屏幕上，主要由视变换和后面要介绍的投影变换、视口变换等决定。</p>
<p>其中视变换阶段，通过假想的相机来处理矩阵计算能够方便处理。对于OpenGL来说并不存在真正的相机，所谓的相机坐标空间(camera space 或者eye space)只是为了方便处理，而引入的坐标空间。</p>
<p>在现实生活中，我们通过移动相机来拍照，而在OpenGL中我们通过以相反方式调整物体，让物体以适当方式呈现出来。例如，初始时，相机镜头指向-z轴，要观察-z轴上的一个立方体的右侧面，那么有两种方式(以下y轴应该指代的是物体那里的y轴)：</p>
<ul>
<li>相机绕着+y轴，旋转+90度，此时相机镜头朝向立方体的右侧面，实现目的。注意这时立方体并没有转动</li>
<li>相机不动，让立方体绕着+y轴，旋转-90度，此时也能实现同样的目的。注意这时相机没有转动。</li>
</ul>
<p>在OpenGL中，采用方式2来完成物体成像的调整。例如下面的图表示了假想的相机</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/3.png)

</center>

<p>接下来我们详细看一下视变换矩阵数学上的推导。</p>
<h2 id="视变换矩阵的推导"><a href="#视变换矩阵的推导" class="headerlink" title="视变换矩阵的推导"></a>视变换矩阵的推导</h2><h3 id="坐标系生成"><a href="#坐标系生成" class="headerlink" title="坐标系生成"></a>坐标系生成</h3><p>相机坐标系由相机位置eye和UVN基向量(或者说由forward, side ,up）构成，如下图所示：</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/4.png)

</center>
各个参数的含义如下：
- 相机位置 也称为观察参考点 (View Reference Point) 在**世界坐标系**下指定相机的位置eye。
- 相机镜头方向，由相机位置和相机指向的目标(target)位置计算出，forwrad=(target−eye)。
- 相机顶部正朝向: View Up Vector 确定在相机哪个方向是向上的，一般取(0, 1, 0)。这个参数稍后详细解释。

上面的图简化为：
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/5.png)

</center>

<p>在使用过程中，我们是要指定的参数即为相机位置(观察参考点 (View Reference Point) 在世界坐标系下指定相机的位置$eye$)，相机指向的目标位置($target$，同世界坐标下)和$viewUp vector$<strong>三个参数</strong>。</p>
<ol>
<li>首先计算相机镜头方向$forward = target - eye$，并进行标准化：<script type="math/tex; mode=display">
forward = \frac{forward}{\left \| forward \right \|}</script></li>
<li>根据$view-up vector$和$forward$确定相机的$side$向量:<script type="math/tex; mode=display">
viewUp = \frac{viewUp}{\left \| viewUp \right \|}</script><script type="math/tex; mode=display">
side = forward \times viewUp</script></li>
<li>根据$forward$和$side$计算$up$向量:<script type="math/tex; mode=display">
up = side \times forward</script><blockquote>
<p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。</p>
</blockquote>
</li>
</ol>
<p>这样$eye$位置，以及$forward$、$side$、$up$三个基向量构成一个新的坐标系，注意这个坐标系是一个左手坐标系，因此在实际使用中，需要对$forward$进行一个翻转。</p>
<p>利用$-forward$、$side$、$up$和$eye$来构成一个右手坐标系。</p>
<p>我们的目标是<strong>计算世界坐标系中的物体在相机坐标系下的坐标</strong>，也就是从相机的角度来解释物体的坐标。从一个坐标系的坐标变换到另一个坐标系，这就是不同坐标系间坐标转换的过程。</p>
<h3 id="世界到相机的坐标变换"><a href="#世界到相机的坐标变换" class="headerlink" title="世界到相机的坐标变换"></a>世界到相机的坐标变换</h3><h4 id="计算方法1——直接计算变换矩阵"><a href="#计算方法1——直接计算变换矩阵" class="headerlink" title="计算方法1——直接计算变换矩阵"></a>计算方法1——直接计算变换矩阵</h4><p>要实现不同坐标系之间的坐标转换，需要求取一个变换矩阵。而这个矩阵就是一个坐标系A中的原点和基在另一个坐标系B下的表示。<br>我们将相机坐标系的原点和基，使用世界坐标系表示为($s$代表$side$基向量，$u$代表$up$基向量，$f$代表$forward$基向量)：</p>
<script type="math/tex; mode=display">
(Camera)_{world} = \begin{bmatrix}
s[0] &u[0] &-f[0] &eye_x \\ 
s[1] &u[1] &-f[1] &eye_y \\ 
s[2]& u[2] &-f[2] &eye_z\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><p>现在要求取的是坐标从世界坐标系变换到相机坐标系，则计算点p在相机坐标系下表示为：</p>
<script type="math/tex; mode=display">
[p]_{camera} = [World]_{camera}[p]_{world} = [Camera]_{world}^{-1}[p]_{world} = view[p]_{world}</script><p>即求得视变换矩阵为:</p>
<script type="math/tex; mode=display">
\begin{split}
 view  & = 
 [Camera]_{world}^{-1}\\\\
  & = \begin{bmatrix}
s[0] &s[1] &s[2] &-dot(s,eye) \\ 
u[0] &u[1] &u[2] &-dot(u,eye) \\ 
-f[0]& -f[1] &-f[2] &dot(f,eye)\\ 
0 & 0 & 0 & 1
\end{bmatrix}
  \end{split}</script><p>上面计算逆矩阵的过程中使用到了分块矩阵求逆矩阵的定理：<br>设方阵$A,D$可逆，那么分块矩阵<script type="math/tex">\begin{pmatrix}
A & B\\ 
0 & D
\end{pmatrix}</script><br>可逆，且其可逆矩阵为：</p>
<script type="math/tex; mode=display">
T_{-1} = \begin{pmatrix}
A^{-1} & -A^{-1}BD^{-1}\\ 
0 & D^{-1}
\end{pmatrix}</script><p>这种方式对应的计算代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动构造LookAt矩阵 方式1</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">computeLookAtMatrix1</span><span class="params">(glm::vec3 eye, glm::vec3 target, glm::vec3 viewUp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::vec3 f = glm::normalize(target - eye); <span class="comment">// forward vector</span></span><br><span class="line">    glm::vec3 s = glm::normalize(glm::cross(f, viewUp)); <span class="comment">// side vector</span></span><br><span class="line">    glm::vec3 u = glm::normalize(glm::cross(s, f)); <span class="comment">// up vector</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">lookAtMat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(s.x, u.x, -f.x, <span class="number">0.0</span>), <span class="comment">// 第一列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(s.y, u.y, -f.y, <span class="number">0.0</span>), <span class="comment">// 第二列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(s.z, u.z, -f.z, <span class="number">0.0</span>), <span class="comment">// 第三列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(-glm::dot(s, eye),-glm::dot(u, eye), glm::dot(f, eye), <span class="number">1.0</span>)  <span class="comment">// 第四列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> lookAtMat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方式求取过程中涉及到了分块矩阵的逆矩阵计算，如果不习惯，可以看下面的方式2，这是比较常用的方式。</p>
<h4 id="计算方法2——利用旋转和平移矩阵求逆矩阵"><a href="#计算方法2——利用旋转和平移矩阵求逆矩阵" class="headerlink" title="计算方法2——利用旋转和平移矩阵求逆矩阵"></a>计算方法2——利用旋转和平移矩阵求逆矩阵</h4><p>求取坐标转换矩阵的过程，也可以从另外一个角度出发，即将世界坐标系旋转和平移至于相机坐标系重合，这样这个旋转$R$和平移$T$矩阵的组合矩阵$M=T∗R$，就是将相机坐标系中坐标变换到世界坐标系中坐标的变换矩阵，那么所求的视变换矩阵（世界坐标系中坐标转换到相机坐标系中坐标的矩阵）$view=M−1$.<br>其中$R$就是上面求得的$side$、$up$、$forward$基向量构成的矩阵，如下：</p>
<script type="math/tex; mode=display">
R = \begin{bmatrix}
s[0] &u[0] &-f[2] &0 \\ 
s[1] &u[1] &-f[1] &0 \\ 
s[2]& u[2] &-f[2] &0\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><script type="math/tex; mode=display">
T =  \begin{bmatrix}
0 &0 &0 &eye_x \\ 
0 &0 &0 &eye_y \\ 
0& 0&0 &eye_z\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><p>那么所求的矩阵$view$计算过程如下:</p>
<script type="math/tex; mode=display">
view = (T*R)^{-1} = R^{-1}*T^{-1}</script><p>在计算过程中，使用到了旋转矩阵的性质，即旋转矩阵是正交矩阵，它的逆矩阵等于矩阵的转置。<br>因此所求的:</p>
<script type="math/tex; mode=display">
R^{-1} = \begin{bmatrix}
s[0] &s[1] &s[2] &0 \\ 
u[0] &u[1] &u[2] &0 \\ 
-f[0]& -f[1] &-f[2] &0\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><script type="math/tex; mode=display">
T^{-1} =  \begin{bmatrix}
0 &0 &0 &-eye_x \\ 
0 &0 &0 &-eye_y \\ 
0& 0&0 &-eye_z\\ 
0 & 0 & 0 & 1
\end{bmatrix}</script><p>同样计算得到的视变换矩阵为：</p>
<script type="math/tex; mode=display">
\begin{split}
 view  & = 
R_{T}*T_{-1}\\\\
  & = \begin{bmatrix}
s[0] &s[1] &s[2] &-dot(s,eye) \\ 
u[0] &u[1] &u[2] &-dot(u,eye) \\ 
-f[0]& -f[1] &-f[2] &dot(f,eye)\\ 
0 & 0 & 0 & 1
\end{bmatrix}
  \end{split}</script><p>这种方式对应的计算代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 手动构造LookAt矩阵 方式2</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">computeLookAtMatrix2</span><span class="params">(glm::vec3 eye, glm::vec3 target, glm::vec3 viewUp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::vec3 f = glm::normalize(target - eye); <span class="comment">// forward vector</span></span><br><span class="line">    glm::vec3 s = glm::normalize(glm::cross(f, viewUp)); <span class="comment">// side vector</span></span><br><span class="line">    glm::vec3 u = glm::normalize(glm::cross(s, f)); <span class="comment">// up vector</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">rotate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(s.x, u.x, -f.x, <span class="number">0.0</span>), <span class="comment">// 第一列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(s.y, u.y, -f.y, <span class="number">0.0</span>), <span class="comment">// 第二列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(s.z, u.z, -f.z, <span class="number">0.0</span>), <span class="comment">// 第三列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)  <span class="comment">//  第四列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">    glm::mat4  translate;</span><br><span class="line">    translate = glm::translate(translate, -eye);</span><br><span class="line">    <span class="keyword">return</span> rotate * translate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="建构改变基的矩阵"><a href="#建构改变基的矩阵" class="headerlink" title="建构改变基的矩阵"></a>建构改变基的矩阵</h2><p>想必读到这会对上面变基的矩阵感到迷糊，为什么另一个坐标空间的基坐标就是旋转坐标了呢。接下来我们对这部分的数学展开说说。</p>
<p>在游戏和计算机图形学里，经常把物体的位置、定向和缩放从某个坐标系转换至另一个坐标系。我们称此运算为基的变更。</p>
<p>坐标系是相对的。即是说，若想在三维空间中定义一组轴，必须指明其位置、定向和缩放的数值是相对于另外一组轴的（否则那些数值是没有意义的）。我们定义的其他空间直接或间接的相对于世界空间。</p>
<p>首先我们提出一个结论：<strong>线性变换由基及变换后基的值唯一确定，通过计算线性变换后基的值可以得到线性变换对应的矩阵A。</strong></p>
<p>定理：设$u_1,u_2,···,u_n$是线性空间$U$的一个基，线性空间$V$包含向量$v_1,v_2,···,v_n$(可以相同)。那么存在唯一的线性变换$T:U\rightarrow V$使得：$T(u_i) = v_i(1\leqslant i\leqslant n)$.</p>
<p>这个定理告诉我们: 只要知道了线性空间$U$的给定基$u_1,u_2,⋯,u_n$在线性变换$T$下对应的值$T(u_1),T(u_2),⋯,T(u_n)$，线性变换$T$也就由$u_i$及$T(u_i)$的对应关系确定了。<br>这个定理的作用就好比，两点确定一条直线。因此我们可以通过计算:<br>$A=(T(u_1),T(u_2),⋯,T(u_n))$来获取线性变换$T$对应的矩阵$A$。</p>
<p>也就是说，矩阵$A$的列向量，由$T(u_i)$在基$u_1,u_2,⋯,u_n$下的坐标唯一确定。同时给出一个矩阵$A$作为线性变换$T$在基$u_1,u_2,⋯,u_n$下的矩阵，也就给出了该基在线性变换T下对应的值$T(u_1),T(u_2),⋯,T(u_n)$，从而确定了线性变换$T$。这表明线性变换$T$与矩阵之间存在一一对应关系，上面已经证明了这个结论。</p>
<p>例如对于绕z轴旋转矩阵，从基和转换后基的角度，也就是从$x,y$轴来看，$x$转换后为$x′$，$y$转换后为$y′$，如下图所示:</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/6.png)

</center>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/7.png)

</center>
因此可以顺利的写出旋转矩阵为:
$$
R(\theta) = \begin{bmatrix}
cos\theta & -sin\theta\\ 
sin\theta & cos\theta
\end{bmatrix}
$$
矩阵第一列即为$x$转换后的$x′$轴的对应的坐标，第二列即为$y$转换后的$y′$轴对应的坐标。显然这个计算方法，比利用极坐标公式来得快。

在后面使用OpenGL模型变换矩阵时，经常要使用到这个方法，理解了这一点后面理解模型变换矩阵就会变得简单。

## OpenGL中视变换的实现
在OpenGL中，我们可以通过函数glm::lookAt来实现相机指定，这个函数计算的就是上面求出的视变换矩阵。以前glu版本实现为gluLookAt，这两个函数完成的功能是一样的，参数定义如下：
API lookAt ( GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)
其中$eye$指定相机位置，$center$指定相机指向目标位置$target$，$up$指定$viewUp$向量。

还记得之前的那个问题吗，初始时，相机镜头指向-z轴，要观察-z轴上的一个立方体的右侧面，我们可以怎么设置我们的lookat矩阵呢?
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/8.png)

</center>

<p>默认情况下相机位于$(0,0,0)$，指向$-z$轴，对应$eye = (0,0,0), center = (0,0,-1), up = (0,1,0)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::lookAt(glm::vec(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>),</span><br><span class="line">            glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>),</span><br><span class="line">            glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><br>第一种方式，相机绕着+y轴旋转90度，相机指向-x轴，则等价于$eye = (0,0,0), center = (-1,0,0), up = (0,1,0)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view &#x3D;glm::lookAt(glm::vec(0.0f,0.0f,0.0f),</span><br><span class="line">                            glm::vec3(-1.0f, 0.0f, 0.0f),</span><br><span class="line">                            glm::vec3(0.0f, 1.0f, 0.0f));</span><br></pre></td></tr></table></figure><br>上述第二种方式，通过立方体绕着+y轴旋转-90度，则得到的矩阵M,相当于:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::rotate(glm::mat4(<span class="number">1.0</span>), glm::radians(<span class="number">-90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure></p>
<p>这里得到的矩阵M和上面的矩阵view是相同的，可以自行验证下。也就是说，通过旋转相机+y轴90度，和旋转立方体+y轴-90度，最终计算得到的矩阵相同。调整相机来得到观察效果，可以通过相应的方式来调整物体达到相同的效果。在OpenGL中并不存在真正的相机，这只是一个虚构的概念。</p>
<h2 id="视角"><a href="#视角" class="headerlink" title="视角"></a>视角</h2><p><code>glm::LookAt</code>函数需要一个<code>位置</code>、<code>目标</code>和<code>上向量</code>。它会创建一个和在上一节使用的一样的观察矩阵。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), </span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><br>一般我们不改动上向量（其实不是真正最后观察坐标中的上向量，我们计算右向量使用的那个上向量）。我们可以改动位置和目标，改动位置得到的是从不同位置看向目标时看到的结果（一般我们是走进走远或者左右走动，也对应着z轴和x轴，不怎么会用到y轴）。而改动目标则可以模拟在同一个位置看向不同方向得到的结果。打个比方，好比有个房子在原地，修改位置是你在不同的位置看同一点，修改目标是你站在那里扫视它（一般我们就是左右看（绕y轴），上下看（绕x轴），也就是偏航角和俯仰角）。</p>
<p>这里我们再详细讨论一下如何修改lookat矩阵达到自由转换视角。具体实现可以参考教程1.7。</p>
<p>截至目前我们使用的都是欧拉角，其实对于理论逻辑/底层计算来讲，都应该使用四元数而并非欧拉角，因为欧拉角会出现<code>万向节死锁</code>。<a target="_blank" rel="noopener" href="https://blog.csdn.net/Jaihk662/article/details/106519595">这里</a>有个详细的例子。</p>
<p>不过以下还是基于欧拉角进行讨论。我们已经知道了三种欧拉角。</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/9.png)

</center>

<ul>
<li><strong>俯仰角(Pitch)</strong>：沿x轴旋转的角，从上往下看的角</li>
<li><strong>偏航角(Yaw)</strong>：沿y轴旋转的角，从左往右看的角</li>
<li><strong>滚转角(Roll)</strong>：沿z轴旋转的角（对于摄像机而言，一般不关心这个）</li>
</ul>
<p>在观察空间我们一般只用到俯仰角和偏航角。可以理解毕竟滚转角相当于我们让摄像机头绕镜头旋转，不是常规操作。</p>
<p>关于坐标轴：</p>
<ul>
<li><strong>自身坐标系</strong>：物体自身的坐标轴，显然如果物体进行了俯仰、偏航、滚筒的旋转操作，那么坐标轴方向也会被改变</li>
<li><strong>世界坐标系</strong>：和物体无关，用来描述物体在世界中的位置，有唯一的原点和轴向</li>
<li><strong>惯性坐标系</strong>：自身坐标系到世界坐标系的过渡，原点为对应物体的原点，会随物体的移动而改变，轴向和世界坐标系的轴向一致，不会因为物体的旋转操作而改变</li>
</ul>
<p>我们假设一个物体的位置是$(5, 6, 15)$，欧拉角是$({50}^{\circ}, {30}^{\circ}, {70}^{\circ})$:</p>
<ul>
<li><strong>对于物体移动，从(0, 0, 0)到(5, 6, 15)，按照世界坐标/惯性坐标的轴向移动</strong>：顺序无关，也就说按照(0, 0, 0) ; (5, 0, 0) ; (5, 6, 0) ; (5, 6, 15)的方式移动和按照(0, 0, 0);  (0, 6, 0) ; (0, 6, 15) ; (5, 6, 15)的方式移动不会影响物体的最终位置</li>
<li><strong>对于物体移动，从(0, 0, 0)到(5, 6, 15)，按照自身轴向移动</strong>：顺序无关，同上，毕竟移动并不会改变自身坐标轴的朝向</li>
<li><strong>对于物体旋转，从(0, 0, 0)到</strong>$({50}^{\circ}, {30}^{\circ}, {70}^{\circ})$，按照世界坐标/惯性坐标的轴向旋转：顺序有关！</li>
<li><strong>对于物体旋转，从(0, 0, 0)到</strong>$({50}^{\circ}, {30}^{\circ}, {70}^{\circ})$，按照自身坐标系轴向旋转：顺序有关，同上，这个就很明显了，因为你每次旋转都会导致坐标轴同时发生改变。</li>
</ul>
<p>看的出来涉及到视角还是比较复杂的，光光一个欧拉角我们是无法定义物体最后的状态的，我们要确定好旋转次序和轴。</p>
<p>LookAt里面有3个属性，摄像机位置，目标位置和世界上向量，改变摄像机视角的方法正是改变这个目标位置。换句话说，我们其实在确定摄像机坐标系中的z轴。我们在世界坐标系中定义它。那么这个目标位置我们又怎么和欧拉角联系到一起呢。</p>
<p>这部分我目前还不是很清楚，等后续再来补充。目前的理解是通过定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos   = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br><span class="line">view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure><br>令鼠标左右上下代表着偏转角和俯仰角，相当于是在利用两个欧拉角定义世界坐标系（也能认为是惯性坐标系下）得到的方向向量。</p>
<h1 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h1><p>投影变换通过指定视见体(viewing frustum)来决定场景中哪些物体将可能会呈现在屏幕上。在视见体中的物体会出现在投影平面上，而在视见体之外的物体不会出现在投影平面上。投影包括很多类型，OpenGL中主要考虑透视投影(perspective projection)和正交投影( orthographic projection)。两者之间存在很大的区别，如下图所示(图片来自Modern OpenGL)：</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/10.png)

</center>

<p>上面的图中，红色和黄色球在视见体内，因而呈现在投影平面上，而绿色球在视见体外，没有在投影平面上成像。</p>
<p>指定视见体通过$(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)$6个参数来指定。注意在相机坐标系下，相机指向-z轴，nearVal和farVal表示的剪裁平面分别为:近裁剪平面$z=−nearVal$，以及远裁剪平面$z=−farVal$。推导投影矩阵，就要利用这6个参数。<strong>在OpenGL中成像是在近裁剪平面上完成。</strong></p>
<h2 id="透视投影矩阵的推导"><a href="#透视投影矩阵的推导" class="headerlink" title="透视投影矩阵的推导:"></a>透视投影矩阵的推导:</h2><p>透视投影中，相机坐标系中点被映射到一个标准立方体中，即规范化设备坐标系中，其中$[l,r]$映射到$[−1,1]$，$[b,t]$映射到$[-1,1]$中，以及$[n,f]$被映射到$[−1,1]$，如下图所示：</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/11.png)

</center>

<blockquote>
<p>注意到上面的相机坐标系为右手系，而NDC中+z轴向内，为左手系。</p>
</blockquote>
<h3 id="我们的目标"><a href="#我们的目标" class="headerlink" title="我们的目标"></a>我们的目标</h3><p>求出投影矩阵的目标就是要找到一个透视投影矩阵P使得下式成立：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_c\\ 
y_c\\ 
z_c\\ 
w_c
\end{bmatrix} = P \ast 
\begin{bmatrix}
x_e\\ 
y_e\\ 
z_e\\ 
w_e
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{bmatrix}
x_n\\ 
y_n\\ 
z_n
\end{bmatrix} = 
\begin{bmatrix}
x_c/w_c\\ 
y_c/w_c\\ 
z_c/w_c
\end{bmatrix}</script><p>上面的除以$w_clip$过程被称为透视除法，要找到我们需要的矩阵P，我们需要利用两个关系:</p>
<ul>
<li>投影位置$x<em>p$,$y_p$和相机坐标系中点$x_e$,$y_e$之间关系。投影后对于z分量都是$z</em>{p}=-nearVal$。</li>
<li>利用$x<em>p$，$y_p$和 $x</em>{ndc}$，$y<em>{ndc}$ 关系求出$x</em>{clip}$,$y_{clip}$。</li>
<li>利用$z<em>n$与$z_e$关系得出$z</em>{clip}$</li>
</ul>
<blockquote>
<p>以上用到了几个注脚，其中e指代eye(观察坐标)，c指代clip(裁剪坐标)。p指代projection(投影坐标)，ndc指代标准设备坐标系。我们的目标就是将相机坐标系中点$(x<em>e,y_e,z_e)$映射到一个标准立方体$(x</em>{ndc},y<em>{ndc},z</em>{ndc})$中。</p>
</blockquote>
<h3 id="计算投影平面上的位置"><a href="#计算投影平面上的位置" class="headerlink" title="计算投影平面上的位置"></a>计算投影平面上的位置</h3><p>投影时原先位于相机坐标系中的点$p=(x_e,y_e,z_e)$投影到投影平面后，得到点$p′=(x_p,y_p,−nearVal)$。具体过程如下图所示:</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/12.png)

</center>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/13.png)

</center>

<p>需要空间想象一下，可以得出左边的图是俯视图，右边是侧视图。利用三角形的相似性，通过俯视图可以得到$\frac{x_p}{x_e} = \frac{-n}{z_e}$，即：</p>
<script type="math/tex; mode=display">
x_p = -\frac{nx_e}{z_e}</script><p>同理通过侧视图可以得到：</p>
<script type="math/tex; mode=display">
y_p =- \frac{ny_e}{z_e}</script><p>可以发现他们都除以了$-z_e$这个量，并且与之成反比。再结合我们对于透视除法的理解，我们应当令$w_c = -z_e$，相应矩阵P的形式如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_c\\ 
y_c\\ 
z_c\\ 
w_c
\end{bmatrix} = \begin{bmatrix}
. & . & . &. \\ 
. & . &.  &. \\ 
 .& . & . &. \\ 
0 & 0 & -1 & 0
\end{bmatrix}
 \ast 
\begin{bmatrix}
x_e\\ 
y_e\\ 
z_e\\ 
w_e
\end{bmatrix}</script><p>下面利用投影点和规范化设备坐标的关系计算出矩阵P的前面两行。</p>
<p>对于投影平面上$ x_p$满足 $[l,r]$线性映射到$ [−1,1]$对于 $y_p$满足 $[b,t]$线性映射到 $[−1,1]$。根据图可以得到线性关系。</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/14.png)

</center>

<p>再结合上面算出的$x_p = -\frac{nx_e}{z_e}$和$y_p =- \frac{ny_e}{z_e}$，代入提取可以得到：</p>
<script type="math/tex; mode=display">
x_n = \frac{(\frac{2x_en}{r-l}+\frac{r+l}{r-l} \ast z_e)}{-z_e}</script><script type="math/tex; mode=display">
y_n = \frac{(\frac{2y_en}{t-b}+\frac{t+b}{t-b} \ast z_e)}{-z_e}</script><p>相应的我们可以得到裁剪坐标（看上面我们的目标出可知，矩阵是直接相乘的，透视除法其实是顶点着色器自动完成的所以矩阵得到的是裁剪坐标）。</p>
<script type="math/tex; mode=display">
x_c = \frac{2n}{r-l}x_e+\frac{r+l}{r-l} \ast z_e</script><script type="math/tex; mode=display">
y_c = \frac{2n}{t-b}y_e+\frac{t+b}{t-b} \ast z_e</script><p>再次完善我们的投影矩阵P得到：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_c\\ 
y_c\\ 
z_c\\ 
w_c
\end{bmatrix} = \begin{bmatrix}
\frac{2n}{r-l} &0 & \frac{r+l}{r-l} &0 \\ 
0 & \frac{2n}{t-b} &\frac{t+b}{t-b} &0 \\ 
 0& 0 & A &B \\ 
0 & 0 & -1 & 0
\end{bmatrix}
 \ast 
\begin{bmatrix}
x_e\\ 
y_e\\ 
z_e\\ 
w_e
\end{bmatrix}</script><p>由于$z_e$投影到平面时结果都为$−n$，因此寻找$z_n$与之前的$x$,$y$分量不太一样。我们知道$z_n$与$x$,$y$分量无关，所以在上面的矩阵我们令$z_c = Az_e+Bw_e(z_n = \frac{Az_e+Bw_e}{-z_e})$，又观察坐标系中$w_e=1$，所以我们有：</p>
<script type="math/tex; mode=display">
z_n = \frac{Az_e+B}{-z_e}</script><p>要求出系数A,B则，利用$z_n$与$z_e$的映射关系为：$(-n,-1)$和$(-f,1)$，像上面一样写线性关系式(两点式，上面是用的点斜式)可以得到：</p>
<script type="math/tex; mode=display">
z_n = \frac{-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n}}{-z_e}</script><p>即可得到A和B。代入可得完整的矩阵P的形式为：</p>
<script type="math/tex; mode=display">
P = \begin{bmatrix}
\frac{2n}{r-l} &0 & \frac{r+l}{r-l} &0 \\ 
0 & \frac{2n}{t-b} &\frac{t+b}{t-b} &0 \\ 
 0& 0 & -\frac{f+n}{f-n} &-\frac{2fn}{f-n}\\ 
0 & 0 & -1 & 0
\end{bmatrix}</script><p>上述矩阵时一般的视见体矩阵，如果视见体是对称的，即满足$r=−l,t=−b$，则矩阵$P$可以简化为：</p>
<script type="math/tex; mode=display">
P = \begin{bmatrix}
\frac{n}{r} &0 &0 &0 \\ 
0 & \frac{n}{t} &0 &0 \\ 
 0& 0 & -\frac{f+n}{f-n} &-\frac{2fn}{f-n}\\ 
0 & 0 & -1 & 0
\end{bmatrix}</script><h3 id="Zfighting问题"><a href="#Zfighting问题" class="headerlink" title="Zfighting问题"></a>Zfighting问题</h3><p>根据上面</p>
<script type="math/tex; mode=display">
z_n = \frac{-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n}}{-z_e}</script><p>这是一个非线性关系函数，作图如下：</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/15.png)

</center>
从左边图我们可以看到，在近裁剪平面附近$z_n$值变化比较大，精确度较好；而在远裁剪平面附近，有一段距离内，$z_n$近乎持平，精确度不好。当增大远近裁剪平面的范围$[−n,−f]$后，如右边图所示，我们看到在远裁剪平面附近，不同相机坐标$z_e$对应的$z_n$相同，精确度低的现象更为明显，这种深度的精确度引起的问题称之为zFighting。要尽量减小$[-n,-f]$的范围，以减轻zFighting问题。


### gluPerspective
以上指定视见体通过$(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)$6个参数来指定，另外一种经常使用的方式是通过 **视角(Fov)，宽高比(Aspect)**来指定透视投影，例如旧版中函数`gluPerspective`,也是我们用到的教程中的：
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//API void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);</span></span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)screenWidth/(<span class="keyword">float</span>)screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>
其中指定fovy指定视角，aspect指定宽高比，zNear和zFar指定剪裁平面。fovy的理解如下图所示([来自opengl 投影](http://www.gimoo.net/t/1507/55a62113251f2.html))：
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/16.png)

</center>
这些参数指定的是一个对称的视见体，如下图所示：

<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/17.png)

</center>

<p>由这些参数，可以得到：</p>
<script type="math/tex; mode=display">h = near \ast tan(\frac{\theta}{2})</script><script type="math/tex; mode=display">w = h \ast aspect</script><p>再对应到上面公式里需要的6个参数，后两个不变，前四个对应为：</p>
<script type="math/tex; mode=display">r = w, l = -r</script><script type="math/tex; mode=display">t = h, b=-t</script><p>则得到<code>Fov透视投影矩阵</code>为：</p>
<script type="math/tex; mode=display">
P = \begin{bmatrix}
\frac{1}{aspect \cdot tan(\frac{\theta}{2})} &0 &0 &0 \\ 
0 &\frac{1}{tan(\frac{\theta}{2})} &0 &0 \\ 
 0& 0 & -\frac{f+n}{f-n} &-\frac{2fn}{f-n}\\ 
0 & 0 & -1 & 0
\end{bmatrix}</script><h2 id="正交投影矩阵的推导"><a href="#正交投影矩阵的推导" class="headerlink" title="正交投影矩阵的推导"></a>正交投影矩阵的推导</h2><p>相比于透视投影，正交投影矩阵的推导要简单些，如下图所示：</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/18.png)

</center>

<p>对于正交投影，有$x_p=x_e,y_p=y_e$，因而可以直接利用$x_e$与$x_n$的映射关系：$[l,−1],[r,1]$，利用$y_e$和$y_n$的映射关系：$[b,−1],[t,1]$，以及$z_e$和$z_n$的映射关系：$[−n,−1],[−f,1]$。得到：</p>
<script type="math/tex; mode=display">
x_n = \frac{2}{r-l}x_e-\frac{r+l}{r-l}</script><script type="math/tex; mode=display">
y_n =\frac{2}{t-b}y_e-\frac{t+b}{t-b}</script><script type="math/tex; mode=display">
z_n =\frac{-2}{f-n}z_e-\frac{f+n}{f-n}</script><p>对于正交投影而言，$w$成分是不必要的，保持为1即可，则所求投影矩阵第四行为$(0,0,0,1)$，$w$保持为1，则NDC坐标和剪裁坐标相同，从而得到正交投影矩阵为:</p>
<script type="math/tex; mode=display">
O = \begin{bmatrix}
\frac{2}{r-l} &0 &0 &-\frac{r+l}{r-l}  \\ 
0 &\frac{2}{t-b} &0 &-\frac{t+b}{t-b}  \\ 
 0& 0 & -\frac{2}{f-n} &-\frac{f+n}{f-n}\\ 
0 & 0 &0 & 1
\end{bmatrix}</script><p>还可以看做把视见体的中心移动到规范视见体的中心即原点处，然后缩放视见体使得它的每条边长度都为2，进行这一过程的变换表示为：</p>
<script type="math/tex; mode=display">
O= \begin{bmatrix}
\frac{2}{r-l} &0 &0 &0 \\ 
0 &\frac{2}{t-b} &0 &0 \\ 
 0& 0 & \frac{2}{n-f} &0\\ 
0 & 0 &0 & 1
\end{bmatrix} \ast
 \begin{bmatrix}
1 &0 &0 &-\frac{r+l}{2} \\ 
0 &1&0 &-\frac{t+b}{2}  \\ 
 0& 0 &1 &-\frac{f+n}{2}\\ 
0 & 0 &0 & 1
\end{bmatrix}</script><p>如果视见体是对称的，即满足r=−l,t=−b，则矩阵O可以简化为：</p>
<script type="math/tex; mode=display">
O = \begin{bmatrix}
\frac{1}{r} &0 &0 &0  \\ 
0 &\frac{1}{t} &0 &0 \\ 
 0& 0 & -\frac{2}{f-n} &-\frac{f+n}{f-n}\\ 
0 & 0 &0 & 1
\end{bmatrix}</script><h1 id="视口变换矩阵"><a href="#视口变换矩阵" class="headerlink" title="视口变换矩阵"></a>视口变换矩阵</h1><p>经过上述的投影变换，我们已经将观察坐标$(x_e,y_e,z_e)$变换成了NDC坐标$(x_n,y_n,z_n)$，视变换是将NDC坐标转换为显示屏幕坐标的过程，如下图所示：</p>
<center>

![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/19.png)

</center>

<p>视口变化通过函数:<br><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtmlhttps://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml">glViewport(GLint , GLint , GLsizei , GLsizei );</a><br><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml">glDepthRangef(GLclampf , GLclampf );</a></p>
<p>两个函数来指定。其中$(s_x,s_y)$表示窗口的左下角，$n_s$和$f_s$指定远近剪裁平面到屏幕坐标的映射关系。<br>使用线性映射关系如下：</p>
<script type="math/tex; mode=display">
x:(-1,s_x),(1,s_x+w_s)</script><script type="math/tex; mode=display">
y:(-1,s_y),(1,s_y+h_s)</script><script type="math/tex; mode=display">
y:(-1,n_s),(1,f_s)</script><p>求出线性映射函数为:</p>
<script type="math/tex; mode=display">
x_s = \frac{w_s}{2}x_n + s_x + \frac{w_s}{2}</script><script type="math/tex; mode=display">
y_s = \frac{h_s}{2}y_n + s_y + \frac{h_s}{2}</script><script type="math/tex; mode=display">
z_s = \frac{f_s - n_s}{2}z_n  + \frac{n_s + f_s}{2}</script><p>则由上述式子得到视口变换矩阵为：</p>
<script type="math/tex; mode=display">
viewPort = \begin{bmatrix}
\frac{w_s}{2} &0 &0 &s_x + \frac{w_s}{2}  \\ 
0 &\frac{h_s}{2} &0 &s_y + \frac{h_s}{2} \\ 
 0& 0 & \frac{f_s - n_s}{2} &\frac{n_s + f_s}{2}\\ 
0 & 0 &0 & 1
\end{bmatrix}</script>
        <p class="suffix-end">__END__</p>
        <div class="suffix-box">
            <div class="suffix-box-left">
                <img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/avatar/avator1.jpg" alt="Dinghy">
            </div>
            <div class="suffix-box-right">
                <span class="suffix-box-title">文章作者</span>：Dinghy
                <br>
                <span class="suffix-box-title">文章出处</span>：<a href="/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A9%E9%98%B5%E8%AF%A6%E8%A7%A3/" target="_blank">OpenGL学习笔记-矩阵详解</a>
                <br>
                <span class="suffix-box-title">作者签名</span>：静如瘫痪,动如癫狂.
                <br>
                <span class="suffix-box-title">关于主题</span>：<a href="https://github.com/first19326/Hexo-LiveForCode" target="_blank">Hexo - Live For Code</a>
                <br>
                <span class="suffix-box-title">版权声明</span>：文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议，转载请注明出处
                <br>
            </div>
            <div style="clear: both;"></div>
        </div>
    </div>
    <div class="article-footer">
        
            <div class="category">
                分类：
                
                    <a href="/category/Learning/">Learning</a>
                
            </div>
        
        
            <div class="tag">
                标签：
                
                    <a href="/tag/OpenGL/">OpenGL</a>
                
            </div>
        
        <div class="article-prev-next">
            
                <a href="/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-7-%E6%91%84%E5%83%8F%E6%9C%BA/" class="prev-prefix">« </a> 上一篇：    <a href="/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-7-%E6%91%84%E5%83%8F%E6%9C%BA/" title="发布于 2020-12-07 09:02">OpenGL学习笔记1.7-摄像机</a>
                <br>
            
            
                <a href="/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-6-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" class="next-prefix">» </a> 下一篇：    <a href="/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-6-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/" title="发布于 2020-12-07 08:26">OpenGL学习笔记1.6-坐标系统</a>
            
        </div>
    </div>
    
    <div class="article-comments">
        <div class="comments-title">
            评论列表
        </div>
        <div class="comments-content">
        </div>
    </div>

</div>

    </div>
</div>
    <div id="footer"></div>
    <div id="sidebar">
    <div class="menu-wrap" style="display:none;">
        <nav class="menu">
            <div class="menu-introduce"> 
                <div class="introduce-avatar"></div> 
                <div class="introduce-info"> 
                    <div class="introduce-user"><span></span></div>        
                </div> 
            </div> 
            <div class="menu-list">
                <ul></ul> 
            </div> 
            <div class="menu-link"></div> 
        </nav>
        <button class="menu-button-close"></button>
        <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
            </svg>
        </div>
    </div>
    <button class="menu-button-open">MENU</button>
    <div class="menu-cover"></div>
</div>
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/search.css">
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/iscroll.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/instantsearch.min.js"></script>
<div class="search-window">
    <div class="search-content">
        <div class="search-content-icon">
            <i class="iconfont icon-search"></i>
        </div>
        <div id="search-input" class="search-input"></div>
    </div>

    <div class="search-scroll">
        <div class="search-result">
            <div id="search-stats" class="search-stats"></div>
            <div id="search-hits"></div>
            <div id="search-pagination" class="search-pagination"></div>
        </div>
    </div>

    <span class="search-close-icon">
        <i class="iconfont icon-close"></i>
    </span>
</div>
    <div id="tools">
    <div class="progressbar-top"></div>
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/APlayer.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/APlayer.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/Meting.min.js"></script>
    <meting-js id="3778678" lrcshow="false" server="netease" type="playlist" fixed="true" autoplay="false" loop="all" order="random" preload="auto" volume="0.67" mutex="true"></meting-js>
    <div class="wrap-right"></div>
    <div class="loading"></div>
</div>
    <script>
    window.config = {
        GitHubUserName     : 'Dinghyt',
        GitHubRepositories : 'dlog',

        BlogUser      : 'Dinghy',
        BlogAvatar    : 'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/avatar/avator1.jpg',
        BlogStartDate : '2020-10-28',

        WebsiteTitleBlur         : '(◍´꒳`◍) Hi, little biscuit',
        WebsiteTitleBlurTimeOut  : 500,
        WebsiteTitleFocus        : '(*´∇｀*) Welcome Back',
        WebsiteTitleFocusTimeOut : 1000,
        WebsiteFavicon           : 'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/website/logo.jpg',

        ProgressBar: {
            id       : 'topProgressBar',
            color    : '#77B6FF',
            height   : '2px',
            duration : 0.2
        },

        Loading: {
            rebound: {
                tension  : 16,
                friction : 5
            },
            spinner: {
                id     : 'spinner',
                radius : 90,
                sides  : 3,
                depth  : 4,
                colors : {
                    background : '#F0F0F0',
                    stroke     : '#272633',
                    base       : '',
                    child      : '#272633'
                },
                alwaysForward : true,
                restAt        : 0.5,
                renderBase    : false
            }
        },

        HomeHeaderAnimationRendered : true,
        HomeHeaderAnimation         : {
            radius      : 15,
            density     : 0.2,
            color       : 'rgba(255, 255, 255, .2)',
            clearOffset : 0.3
        },

        ArticleHeaderAnimationRendered : false,
        ArticleHeaderAnimation         : {
            triW                  : 14,
            triH                  : 20,
            neighbours            : [
                
                    'side',
                
                    'top',
                
                    'bottom',
                
            ],
            speedTrailAppear      : 0.1,
            speedTrailDisappear   : 0.1,
            speedTriOpen          : 1,
            trailMaxLength        : 30,
            trailIntervalCreation : 100,
            delayBeforeDisappear  : 2,
            colors                : [
                
                    '#96EDA6',
                
                    '#5BC6A9',
                
                    '#38668C',
                
                    '#374D84',
                
                    '#BED5CB',
                
                    '#62ADC6',
                
                    '#8EE5DE',
                
                    '#304E7B',
                
            ]
        },

        BackAnimationRendered          : true,
        IEBrowserBackAnimationRendered : false,
        BackAnimation                  : {
            colorSaturation  : '60%',
            colorBrightness  : '50%',
            colorAlpha       : 0.5,
            colorCycleSpeed  : 5,
            verticalPosition : 'random',
            horizontalSpeed  : 200,
            ribbonCount      : 3,
            strokeSize       : 0,
            parallaxAmount   : -0.2,
            animateSections  : true
        },

        HomeHeaderImage : [
            
                'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/header/home1.jpg',
            
                'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/header/home2.jpg',
            
                'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/header/home3.jpg',
            
                'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/header/home7.jpg',
            
        ],
        HomeBannerText  : '所谓障碍都是主观上的。如果你想动手开发什么全新的技术，你不需要几百万美元的资金，你只需要在冰箱里放满比萨和可乐，再有一台便宜的计算机，和为之献身的决心。我们在地板上睡过，我们从河水中趟过。 --约翰·卡马克',

        ArticleHeaderImage : [
            
                'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/header/article1.jpg',
            
                'https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/header/article3.jpg',
            
        ],

        OtherBannerText  : '',

        MenuList : [
            
                {
                    name   : '首页',
                    href   : '/',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '标签',
                    href   : '/tag',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '分类',
                    href   : '/category',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '归档',
                    href   : '/archive',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '赞赏',
                    href   : '/donate',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '关于',
                    href   : '/about',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '订阅',
                    href   : '/atom.xml',    
                    target : '_blank',
                    class  : ''
                },
            
                {
                    name   : '搜索',
                    href   : '',    
                    target : '',
                    class  : 'search'
                },
            
                {
                    name   : '留言板',
                    href   : '/comment',    
                    target : '',
                    class  : ''
                },
            
                {
                    name   : '友情链接',
                    href   : '/friend',    
                    target : '',
                    class  : ''
                },
            
        ],
        MenuLink : [
            
                {
                    icon : 'icon-weibo', 
                    url  : ''
                },
            
                {
                    icon : 'icon-wechat', 
                    url  : ''
                },
            
                {
                    icon : 'icon-qq', 
                    url  : ''
                },
            
                {
                    icon : 'icon-github', 
                    url  : ''
                },
            
        ],

        FooterStyle : 2,
        BottomText  : {
            icon    : '',
            left    : '想牵你的手',
            right   : '然后带你远走'
        },
        ThemeInfo   : false,

        ConsoleList : [
            
                [
                    
                        'Based on cnblogs theme SimpleMemory.',
                    
                        '',
                    
                ],
            
                [
                    
                        'SimpleMemory Author:',
                    
                        'BNDong',
                    
                ],
            
                [
                    
                        'Theme:',
                    
                        'LiveForCode',
                    
                ],
            
        ],

        FontIconExtend : "",

        Donate : {
            paypal  : '',
            bitcoin : '',
            alipay  : '',
            wechat  : ''
        },

        Code : {
            style : 'normal'
        },  

        Search : {
            applicationID : '0798QU8T37M',
            apiKey        : 'abe6b13ded06abb1f11ec41b155aba5f',
            indexName     : 'SOFM',
            hits          : {
                page : 10
            },
            labels        : {
                placeholder : '搜索',
                empty       : '未发现与 「${query}」 相关的内容',
                stats       : '${hits} 条相关条目，使用了 ${time} 毫秒',
            }
        }, 

        Valine : {
            switch         : true,
            el             : '.comments-content',
            appId          : '5pkkzofSWgoMAwy9gziYFTmS-gzGzoHsz',
            appKey         : 'Gps2EgbJuUCCBoKinLrjLK6M',
            placeholder    : 'Type your comments here...',
            avatar         : 'retro',
            meta           : 'nick,mail,link',
            requiredFields : 'nick',
            pageSize       : 5,
            lang           : 'zh-cn',
            visitor        : true,
            enableQQ       : true
        },

        Tocbot : {
            switch                : true,
            tocSelector           : '.toc',
            contentSelector       : '.article-body',
            headingSelector       : 'h1, h2, h3, h4, h5',
            headingsOffset        : 0,
            scrollSmooth          : true,
            scrollSmoothOffset    : -5,
            positionFixedSelector : '.toc',
            positionFixedClass    : 'toc-fixed',
            fixedSidebarOffset    : '',
        },

        Require : {
            baseUrl     : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/",
            waitSeconds : 100
        },

        Meting : {
            id       : "3778678", 
            lrcshow  : false, 
            server   : "netease", 
            type     : "playlist", 
            fixed    : true, 
            autoplay : false, 
            loop     : "all", 
            order    : "random", 
            preload  : "auto", 
            volume   : 0.67, 
            mutex    : true
        },

        LazyLoad : {
            default : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/website/lazyload.svg"
        },
  

        Style : {
            aplayer          : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/APlayer.css",
            archive          : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/archive.css",
            donate           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/donate.css",
            fancybox         : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/jquery.fancybox.css",
            footer           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/footer.css",
            iconfont         : "https://at.alicdn.com/t/font_1546312_l3yohatebw.css",
            index            : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/index.css",
            menuBubble       : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/menu-bubble.css",
            page             : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/page.css",
            post             : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/post.css",
            search           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/search.css",
            tocbot           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/tocbot.css",
            normal           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/normal.css",
            night            : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/night.css",
            clipboard        : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/css/clipboard.css"
        },

        Script: {
            aplayer          : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/APlayer.min.js",
            config           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/require.config.js",
            index            : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/index.js",
            instantSearch    : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/instantsearch.min.js",
            jQuery           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/jquery-3.4.1.min.js",
            loading          : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/loading.js",
            meting           : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/Meting.min.js",
            iscroll          : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/iscroll.js",
            require          : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/require.min.js"
        },

        Font: {
            LongCang   : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/LongCang.css",
            Monda      : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/Monda.css",
            NotoSansSC : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/NotoSansSC.css",
            Playball   : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/Playball.css",
            PTMono     : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/PTMono.css",
            RobotoSlab : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/RobotoSlab.css",
            Rosario    : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/Rosario.css",
            UbuntuMono : "https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/font/UbuntuMono.css"
        },

        Suffix : {
            about : '静如瘫痪,动如癫狂.'
        },
            
        Theme : {
            url  : 'https://github.com/first19326/Hexo-LiveForCode',
            name : 'Hexo - Live For Code'
        }  
    };
</script>
    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/js/index.js"></script>
</body>
</html>

