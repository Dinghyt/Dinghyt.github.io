<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Oh My God</title>
  
  
  <link href="https://idinghy.com/atom.xml" rel="self"/>
  
  <link href="https://idinghy.com/"/>
  <updated>2020-12-07T13:15:55.030Z</updated>
  <id>https://idinghy.com/</id>
  
  <author>
    <name>Dinghy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenGL学习笔记1.7-摄像机</title>
    <link href="https://idinghy.com/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-7-%E6%91%84%E5%83%8F%E6%9C%BA/"/>
    <id>https://idinghy.com/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-7-%E6%91%84%E5%83%8F%E6%9C%BA/</id>
    <published>2020-12-07T13:02:37.000Z</published>
    <updated>2020-12-07T13:15:55.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>官方教程见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/">这里</a></li></ul><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>前面的教程中我们讨论了观察矩阵以及如何使用观察矩阵移动场景（我们向后移动了一点）。OpenGL本身没有摄像机(Camera)的概念，但<strong>我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动</strong>。</p><p>本节我们将会讨论如何在OpenGL中配置一个摄像机，并且将会讨论FPS风格的摄像机，让你能够在3D场景中自由移动。我们也会讨论键盘和鼠标输入，最终完成一个自定义的摄像机类。</p><h1 id="摄像机-观察空间"><a href="#摄像机-观察空间" class="headerlink" title="摄像机/观察空间"></a>摄像机/观察空间</h1><p>当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：<strong>观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标</strong>。要定义一个摄像机，我们需要</p><ul><li>它在世界空间中的位置、</li><li>观察的方向、</li><li>一个指向它右测的向量</li><li>以及一个指向它上方的向量。</li></ul><p>细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.7/1.png)</center><h2 id="摄像机参数"><a href="#摄像机参数" class="headerlink" title="摄像机参数"></a>摄像机参数</h2><h3 id="摄像机位置"><a href="#摄像机位置" class="headerlink" title="摄像机位置"></a>摄像机位置</h3><p>获取摄像机位置很简单。摄像机位置简单来说就是<strong>世界空间</strong>中一个指向摄像机位置的向量。</p><p>我们把摄像机位置设置为上一节中的那个相同的位置：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>不要忘记正z轴是从屏幕指向你的，如果我们希望摄像机向后移动，我们就沿着z轴的正方向移动。</p></blockquote><h3 id="摄像机方向"><a href="#摄像机方向" class="headerlink" title="摄像机方向"></a>摄像机方向</h3><p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正z轴方向的向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraTarget = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure><blockquote><p>方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。</p></blockquote><h3 id="右轴"><a href="#右轴" class="headerlink" title="右轴"></a>右轴</h3><p>我们需要的另一个向量是一个右向量(Right Vector)，它代表摄像机空间的x轴的正方向。为获取右向量我们需要先使用一个小技巧：先定义一个上向量(Up Vector)。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 up = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>); </span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</span><br></pre></td></tr></table></figure><h3 id="上轴"><a href="#上轴" class="headerlink" title="上轴"></a>上轴</h3><p>现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把右向量和方向向量进行叉乘：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure><p>在叉乘和一些小技巧的帮助下，我们创建了所有构成观察/摄像机空间的向量。对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做<a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process">格拉姆—施密特正交化</a>(Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个LookAt矩阵了，它在创建摄像机的时候非常有用。</p><h2 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h2><p>使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是LookAt矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了(这部分详细的推导可以见我的矩阵详解)：</p><script type="math/tex; mode=display">Look At = \begin{bmatrix}R_x&R_y&R_z&0\\U_x&U_y&U_z&0\\D_x&D_y&D_z&0\\0&0&0&0\end{bmatrix}*\begin{bmatrix}1&0&0&-P_x\\0&1&0&-P_y\\0&0&1&-P_y\\0&0&0&1\end{bmatrix}</script><p>其中$R$是右向量，$U$是上向量，$D$是方向向量$P$是摄像机位置向量。都是在世界坐标中的值。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。</p><p>幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵：</p><p><code>glm::LookAt</code>函数需要一个<code>位置</code>、<code>目标</code>和<code>上向量</code>。它会创建一个和在上一节使用的一样的观察矩阵。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), </span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><br>一般不改动上向量（其实不是真正最后观察坐标中的上向量，我们计算右向量使用的那个上向量）。我们可以改动位置和目标，改动位置得到的是从不同位置看向目标时看到的结果（一般我们是走进走远或者左右走动，也对应着z轴和x轴，不怎么会用到y轴）。而改动目标则可以模拟在同一个位置看向不同方向得到的结果。打个比方，好比有个房子在原地，修改位置是你在不同的位置看同一点，修改目标是你站在那里扫视它（一般我们就是左右看（绕y轴），上下看（绕x轴），也就是偏航角和俯仰角）。</p><p>有了以上认识之后我们来创建一个在3D场景中自由移动并且可以视角移动的摄像机。</p><h1 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h1><h2 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h2><p>复用之前显示10个正方体在不同位置的代码，并且让他们不再转动，更方便我们观察。</p><h2 id="实现自由移动"><a href="#实现自由移动" class="headerlink" title="实现自由移动"></a>实现自由移动</h2><p>主要指的就是我们可以改变摄像机的位置。代入自己的话，我们应该是在$x-z$平面移动，$y$为0。<br>那么我们可以定义$view$为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> radius = <span class="number">10.0f</span>;</span><br><span class="line"><span class="keyword">float</span> camX = <span class="built_in">sin</span>(glfwGetTime()) * radius;</span><br><span class="line"><span class="keyword">float</span> camZ = <span class="built_in">cos</span>(glfwGetTime()) * radius;</span><br><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(camX, <span class="number">0.0</span>, camZ), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>)); </span><br></pre></td></tr></table></figure><br>在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。相当于我们围绕着(0,0,0)旋转看到的景象。</p><p>我们需要用到一点三角学的知识来在每一帧创建一个x和z坐标，它会代表圆上的一点，我们将会使用它作为摄像机的位置。通过重新计算x和y坐标，我们会遍历圆上的所有点，这样摄像机就会绕着场景旋转了。我们预先定义这个圆的半径radius，在每次渲染迭代中使用GLFW的glfwGetTime函数重新创建观察矩阵，来扩大这个圆。</p><p>此时的代码为:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// configure global opengl state</span></span><br><span class="line">    <span class="comment">// -----------------------------</span></span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;./shader/vertex_3D_2.txt&quot;</span>, <span class="string">&quot;./shader/fragment_texture_2.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    glm::vec3 cubePositions[] = &#123;</span><br><span class="line">        glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">        glm::vec3(<span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">        glm::vec3(<span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// texture attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="keyword">float</span> borderColor[] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    stbi_set_flip_vertically_on_load(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">                                            <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = stbi_load(<span class="string">&quot;awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.use(); <span class="comment">// don&#x27;t forget to activate/use the shader before setting uniforms!</span></span><br><span class="line">                     <span class="comment">// either set it manually like so:</span></span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass projection matrix to shader (as projection matrix rarely changes there&#x27;s no need to do this per frame)</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------------------------------------------------------------</span></span><br><span class="line">    glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    ourShader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">        glActiveTexture(GL_TEXTURE1);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render container</span></span><br><span class="line">        ourShader.use();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// camera/view transformation</span></span><br><span class="line">        glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);    </span><br><span class="line">        <span class="keyword">float</span> radius = <span class="number">20.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> camX = <span class="built_in">sin</span>(glfwGetTime()) * radius;</span><br><span class="line">        <span class="keyword">float</span> camZ = <span class="built_in">cos</span>(glfwGetTime()) * radius;</span><br><span class="line">        view = glm::lookAt(glm::vec3(camX, <span class="number">0.0</span>, camZ), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">        ourShader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// render boxes</span></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::translate(model, cubePositions[i]);</span><br><span class="line">            <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">            model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>得到的结果是：</p><video width="480" height="320" controls><source src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.7/1.mp4"></video><p>可以看到仿佛是我们在围着一个半径为20f的圆绕着看中心（中心正好也有一个正方体，大概能明白意思）。</p><p>让摄像机绕着场景转的确很有趣，但是让我们自己移动摄像机会更有趣！首先我们必须设置一个摄像机系统，所以在我们的程序前面定义一些摄像机变量很有用：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos   = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br></pre></td></tr></table></figure></p><p>LookAt函数现在成了:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure><br>我们首先将摄像机位置设置为之前定义的$cameraPos$。方向是当前的位置加上我们刚刚定义的方向向量。这样能保证无论我们怎么移动，摄像机都会注视着目标方向。让我们摆弄一下这些向量，在按下某些按钮时更新cameraPos向量。<br> 具体就是在processInput函数中新添加几个需要检查的按键命令：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">float</span> cameraSpeed = <span class="number">0.05f</span>; <span class="comment">// adjust accordingly</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当我们按下<strong>WASD</strong>键的任意一个，摄像机的位置都会相应更新。如果我们希望向前或向后移动，我们就把位置向量加上或减去方向向量。如果我们希望向左右移动，我们使用叉乘来创建一个右向量(Right Vector)，并沿着它相应移动就可以了。这样就创建了使用摄像机时熟悉的横移(Strafe)效果。</p><p>这段代码的意思其实就是在我们定义的向前和向右（z轴和x轴上去进行摄像机位置的摆放），之前我们的轨迹是一个圆，并且向前的向量始终是指向（0，0，0）的但是现在不是，现在我们保持的是向前的向量始终是（0，0，-1），也就是说我们在自己的坐标系中行走。这个坐标系的三轴是不变的，只是位置在改变。特殊的对于这个代码而言，我们定义的摄像机方向的向量是z轴，因此最后其实就是一个和世界坐标反向的平移后的坐标系。</p><h2 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h2><p>这里要注意一下<code>cameraSpeed</code>。目前我们的移动速度是个常量。理论上没什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用$processInput$函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须确保它在所有硬件上移动速度都一样。</p><p>图形程序和游戏通常会跟踪一个<code>时间差(Deltatime)</code>变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p><p>我们跟踪两个全局变量来计算出deltaTime值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> deltaTime = <span class="number">0.0f</span>; <span class="comment">// 当前帧与上一帧的时间差</span></span><br><span class="line"><span class="keyword">float</span> lastFrame = <span class="number">0.0f</span>; <span class="comment">// 上一帧的时间</span></span><br></pre></td></tr></table></figure><br>在每一帧中我们计算出新的deltaTime以备后用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> currentFrame = glfwGetTime();</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br></pre></td></tr></table></figure><br>现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们有了一个在任何系统上移动速度都一样的摄像机。代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// view matrix settings</span></span><br><span class="line">glm::vec3 cameraPos = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// procssInput setting</span></span><br><span class="line"><span class="keyword">float</span> deltaTime = <span class="number">0.0f</span>; <span class="comment">// 当前帧与上一帧的时间差</span></span><br><span class="line"><span class="keyword">float</span> lastFrame = <span class="number">0.0f</span>; <span class="comment">// 上一帧的时间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// configure global opengl state</span></span><br><span class="line">    <span class="comment">// -----------------------------</span></span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;./shader/vertex_3D_2.txt&quot;</span>, <span class="string">&quot;./shader/fragment_texture_2.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    glm::vec3 cubePositions[] = &#123;</span><br><span class="line">        glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">        glm::vec3(<span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">        glm::vec3(<span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// texture attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="keyword">float</span> borderColor[] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    stbi_set_flip_vertically_on_load(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">                                            <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = stbi_load(<span class="string">&quot;awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.use(); <span class="comment">// don&#x27;t forget to activate/use the shader before setting uniforms!</span></span><br><span class="line">                     <span class="comment">// either set it manually like so:</span></span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture1&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass projection matrix to shader (as projection matrix rarely changes there&#x27;s no need to do this per frame)</span></span><br><span class="line">    <span class="comment">// -----------------------------------------------------------------------------------------------------------</span></span><br><span class="line">    glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    ourShader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        <span class="keyword">float</span> currentFrame = glfwGetTime();</span><br><span class="line">        deltaTime = currentFrame - lastFrame;</span><br><span class="line">        lastFrame = currentFrame;</span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">        glActiveTexture(GL_TEXTURE1);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render container</span></span><br><span class="line">        ourShader.use();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// camera/view transformation</span></span><br><span class="line">        glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);    </span><br><span class="line">        view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br><span class="line">        ourShader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// render boxes</span></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::translate(model, cubePositions[i]);</span><br><span class="line">            <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">            model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//float cameraSpeed = 0.05f; // adjust accordingly</span></span><br><span class="line">    <span class="keyword">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)</span><br><span class="line">        cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)</span><br><span class="line">        cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)</span><br><span class="line">        cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在我们有了一个在任何系统上移动速度都一样的摄像机。</p><h2 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h2><p>只用键盘移动没什么意思。这其实意味着我们只能走但是并不能变化我们的坐标系，不能转向，移动很受限制。是时候加入鼠标了！为了能够改变视角，我们需要根据鼠标的输入改变$cameraFront$向量。假设我们已知俯仰角和偏航角。</p><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有3种欧拉角：<code>俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)</code>，下面的图片展示了它们的含义：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.7/2.png)</center><p>俯仰角是描述我们如何往上或往下看的角，可以在第一张图中看到。第二张图展示了偏航角，偏航角表示我们往左和往右看的程度。滚转角代表我们如何翻滚摄像机，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算3D空间中任何的旋转向量了。</p><p>对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角(可以理解的是人只能左右转动脖子，上下转动脖子，不能眼睛绕着脸动)。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。</p><p>oh，maths！</p><center><p><img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.7/3.png" alt="description"></p><p>&lt;/center&gt;<br>如果我们把斜边边长定义为1，我们就能知道邻边的长度是$cos x/h=cos x/1=cos x$，它的对边是$sin y/h=sin y/1=sin y$。这样我们获得了能够得到$x$和$y$方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.7/4.png" alt="description"></p><p>&lt;/center&gt;<br>这个三角形看起来和前面的三角形很像，所以如果我们想象自己在$xz$平面上，看向$y$轴，我们可以基于第一个三角形计算来计算它的长度/y方向的强度(Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定俯仰角的$y$值等于$sin \theta$：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch)); <span class="comment">// 注意我们先把角度转为弧度</span></span><br><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch));<span class="comment">//x和z分量也被影响了</span></span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch));</span><br></pre></td></tr></table></figure><br>对于偏航角：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.7/5.png" alt="description"></p><p>&lt;/center&gt;<br>就像俯仰角的三角形一样，我们可以看到$x$分量取决于$cos(yaw)$的值，$z$值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw)); <span class="comment">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br></pre></td></tr></table></figure></p><p>这里还没有看太懂，还可以参考<a href="https://blog.csdn.net/Jaihk662/article/details/106519595">这里</a>。<br>这样我们就有了一个可以<strong>把俯仰角和偏航角转化为用来自由旋转视角的摄像机的3维方向向量</strong>了。你可能会奇怪：我们怎么得到俯仰角和偏航角？</p><h2 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h2><p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。</p><p>首先我们要告诉GLFW，它应该隐藏光标，并捕捉(Capture)它。捕捉光标表示的是，如果焦点在你的程序上（译注：即表示你正在操作这个程序，Windows中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），光标应该停留在窗口中（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure><p>在调用这个函数之后，无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口。对于FPS摄像机系统来说非常完美。</p><p>为了计算俯仰角和偏航角，我们需要让GLFW监听鼠标移动事件。（和键盘输入相似）我们会用一个回调函数来完成<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure><br>具体函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的xpos和ypos代表当前鼠标的位置。当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个bool变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为xpos和ypos值,避免开头大的跳动</span></span><br><span class="line">    <span class="keyword">if</span>(firstMouse)</span><br><span class="line">    &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算当前帧和上一帧鼠标位置的偏移量</span></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos; </span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line">    <span class="comment">// 鼠标灵敏度值配置</span></span><br><span class="line">    <span class="keyword">float</span> sensitivity = <span class="number">0.05</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line">    <span class="comment">// 把偏移量加到全局变量pitch和yaw上：</span></span><br><span class="line">    yaw   += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于89度的地方（在90度时视角会发生逆转，所以我们把89度作为极限），同样也不允许小于-89度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</span></span><br><span class="line">    <span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line">    <span class="comment">//通过俯仰角和偏航角来计算以得到真正的方向向量：</span></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::radians(yaw)) * <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">    front.z = <span class="built_in">sin</span>(glm::radians(yaw)) * <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">    cameraFront = glm::normalize(front);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以增加一个缩放接口。采用鼠标滚轮来控制投影函数中的fov即可。</p><p>代码是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">projection = glm::perspective(glm::radians(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">glfwSetScrollCallback(window, scroll_callback);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov -= yoffset;</span><br><span class="line">  <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">    fov = <span class="number">1.0f</span>;</span><br><span class="line">  <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">    fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们就实现了一个简单的摄像机系统了，它能够让我们在3D环境中自由移动。</p><p>代码如<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/7.3.camera_mouse_zoom/camera_mouse_zoom.cpp">官方</a>。</p>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记-矩阵详解</title>
    <link href="https://idinghy.com/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A9%E9%98%B5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://idinghy.com/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%9F%A9%E9%98%B5%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-12-07T12:30:13.000Z</published>
    <updated>2020-12-07T13:13:42.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>opengl教程—<a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统</a></li><li>opengl教程—<a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">变换</a></li><li>观察矩阵搬移来自<a href="https://blog.csdn.net/wangdingqiaoit/article/details/51570001">这里</a></li><li>视角部分搬移来自<a href="https://blog.csdn.net/Jaihk662/article/details/106519595">这里</a></li><li>投影矩阵搬移来自<a href="https://blog.csdn.net/wangdingqiaoit/article/details/51589825?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control">这里</a></li><li>songho<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html"> OpenGL Projection Matrix</a></li></ul><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>OpenGL最终的渲染设备是2D的，我们需要将3D表示的场景转换为最终的2D形式，前面使用模型变换和视变换将物体坐标转换到照相机坐标系后，需要进行投影变换，将坐标从相机—&gt;裁剪坐标系，经过透视除法后，变换到规范化设备坐标系(NDC)，最后进行视口变换后，3D坐标才变换到屏幕上的2D坐标，这个过程如下图所示：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/1.png)</center>其中比较关键的就是以下，- 模型矩阵：将物体从局部坐标变换到世界空间坐标- 观察矩阵：将物体从世界坐标变换到观察坐标- 投影矩阵：加上后续自动执行的透视除法将观察坐标变换成标准设备坐标- 视口变换矩阵：将NDC坐标转换为显示屏幕坐标$$V_{screen2D} = M_{viewPort} \cdot M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}$$由此完成了从局部的一个3D的点变到2D屏幕上的过程。看到这里对各个矩阵还是比较迷糊，所以找来了教程从数学的角度来让我们看看各个矩阵背后到底是怎样的。# 模型矩阵我们在OpenGL中通过定义一组顶点来定义一个模型，或者通过其他3D建模软件事先建好模型然后导入到OpenGL中。顶点属性定义了模型。如果我们要在一个场景中不同位置显示同一个模型怎么办？ 如果我们要以不同的比例、不同角度显示同一个模型又怎么办 ？如果继续以类似的顶点属性数据定义同一个模型，调整它满足上述需求的话，不仅浪费显卡内存，而且这个调整的工作量也很大，因此效率很低。更好地解决方法是，我们定义的模型根据需要可以执行放大、缩小等操作来不同比例显示，可以通过平移来放在不同位置，可以通过旋转来按不同角度显示。这种方式就是执行模型变换。模型变换通过对模型执行平移(translation)、缩放(scale)、旋转(rotation)、镜像(reflection)、错切(shear)等操作，来调整模型的过程。通过模型变换，我们可以按照合理方式指定场景中物体的位置等信息。<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/2.png)</center><p>这部分不是很困难，相关的矩阵如下：</p><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>假设缩放向量表示为$\left ( S_1, S_2,S_3 \right )$:</p><script type="math/tex; mode=display">\begin{bmatrix}S_1 & 0 & 0 & 0\\ 0 &  S_2& 0 & 0\\ 0 &  0&  S_3&0 \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}S_1 \cdot x\\ S_2 \cdot y\\ S_3 \cdot z\\ 1\end{bmatrix}</script><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>假设位移向量表示为$\left ( T_x, T_y,T_z \right )$:</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & T_x\\ 0 &  1& 0 & T_y\\ 0 &  0&  1&T_z \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}x + T_x\\ y + T_y\\ z + T_z\\ 1\end{bmatrix}</script><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><h3 id="沿x轴旋转："><a href="#沿x轴旋转：" class="headerlink" title="沿x轴旋转："></a>沿x轴旋转：</h3><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & 0\\ 0 &  cos\theta& -sin\theta & 0\\ 0 &  sin\theta&  cos\theta&0 \\  0& 0 &0  & 1\end{bmatrix}  \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix}  = \begin{bmatrix}x\\ cos\theta \cdot y - sin\theta \cdot z\\ sin\theta \cdot y + cos\theta \cdot z\\ 1\end{bmatrix}</script><h3 id="沿y轴旋转："><a href="#沿y轴旋转：" class="headerlink" title="沿y轴旋转："></a>沿y轴旋转：</h3><script type="math/tex; mode=display">\begin{bmatrix}cos\theta &0 & sin\theta  & 0\\ 0 &  1& 0 & 0\\ -sin\theta & 0 & cos\theta&0 \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}cos\theta \cdot x + sin\theta \cdot z\\ y\\ -sin\theta \cdot x + cos\theta \cdot z\\ 1\end{bmatrix}</script><h3 id="沿z轴旋转："><a href="#沿z轴旋转：" class="headerlink" title="沿z轴旋转："></a>沿z轴旋转：</h3><script type="math/tex; mode=display">\begin{bmatrix}cos\theta & -sin\theta & 0 & 0\\ sin\theta &  cos\theta& 0 & 0\\ 0 &  0& 1&0 \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}cos\theta \cdot x - sin\theta \cdot y\\ sin\theta \cdot x + cos\theta \cdot y\\ z\\ 1\end{bmatrix}</script><h3 id="沿任意轴旋转："><a href="#沿任意轴旋转：" class="headerlink" title="沿任意轴旋转："></a>沿任意轴旋转：</h3><p>其中$\left ( R_x, R_y,R_z \right )$代表任意旋转轴：</p><script type="math/tex; mode=display">\begin{bmatrix}cos\theta + {R_x}^2(1-cos\theta)) & R_xR_y(1-cos\theta)-R_zsin\theta  & R_xR_z(1-cos\theta)+R_ysin\theta & 0\\ R_yR_x(1-cos\theta)+R_zsin\theta &  cos\theta + {R_y}^2(1-cos\theta)& R_yR_z(1-cos\theta)-R_xsin\theta & 0\\ R_zR_x(1-cos\theta)-R_ysin\theta &  R_zR_y(1-cos\theta)+R_xsin\theta& cos\theta + {R_z}^2(1-cos\theta)&0 \\  0& 0 &0  & 1\end{bmatrix}</script><h2 id="矩阵的组合"><a href="#矩阵的组合" class="headerlink" title="矩阵的组合"></a>矩阵的组合</h2><p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该<code>从右向左</code>读这个乘法。建议您在组合矩阵时，<strong>先进行缩放操作，然后是旋转，最后才是位移</strong>，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！在实际中多半是这些变换的组合，一般地执行变换顺序为<code>缩放–&gt;旋转—&gt;平移</code>。在实行模型变换时，要注意变换的顺序和代码中书写的顺序相反。同时对于缩放和旋转变换，要注意不动点不在原点时的处理方法(先把物体的中心移到原点，然后应用旋转矩阵，最后再把物体移回到原处)。</p><h1 id="观察矩阵"><a href="#观察矩阵" class="headerlink" title="观察矩阵"></a>观察矩阵</h1><p>OpenGL成像采用的是虚拟相机模型。在场景中你通过模型变换，将物体放在场景中不同位置后，最终哪些部分需要成像，显示在屏幕上，主要由视变换和后面要介绍的投影变换、视口变换等决定。</p><p>其中视变换阶段，通过假想的相机来处理矩阵计算能够方便处理。对于OpenGL来说并不存在真正的相机，所谓的相机坐标空间(camera space 或者eye space)只是为了方便处理，而引入的坐标空间。</p><p>在现实生活中，我们通过移动相机来拍照，而在OpenGL中我们通过以相反方式调整物体，让物体以适当方式呈现出来。例如，初始时，相机镜头指向-z轴，要观察-z轴上的一个立方体的右侧面，那么有两种方式(以下y轴应该指代的是物体那里的y轴)：</p><ul><li>相机绕着+y轴，旋转+90度，此时相机镜头朝向立方体的右侧面，实现目的。注意这时立方体并没有转动</li><li>相机不动，让立方体绕着+y轴，旋转-90度，此时也能实现同样的目的。注意这时相机没有转动。</li></ul><p>在OpenGL中，采用方式2来完成物体成像的调整。例如下面的图表示了假想的相机</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/3.png)</center><p>接下来我们详细看一下视变换矩阵数学上的推导。</p><h2 id="视变换矩阵的推导"><a href="#视变换矩阵的推导" class="headerlink" title="视变换矩阵的推导"></a>视变换矩阵的推导</h2><h3 id="坐标系生成"><a href="#坐标系生成" class="headerlink" title="坐标系生成"></a>坐标系生成</h3><p>相机坐标系由相机位置eye和UVN基向量(或者说由forward, side ,up）构成，如下图所示：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/4.png)</center>各个参数的含义如下：- 相机位置 也称为观察参考点 (View Reference Point) 在**世界坐标系**下指定相机的位置eye。- 相机镜头方向，由相机位置和相机指向的目标(target)位置计算出，forwrad=(target−eye)。- 相机顶部正朝向: View Up Vector 确定在相机哪个方向是向上的，一般取(0, 1, 0)。这个参数稍后详细解释。上面的图简化为：<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/5.png)</center><p>在使用过程中，我们是要指定的参数即为相机位置(观察参考点 (View Reference Point) 在世界坐标系下指定相机的位置$eye$)，相机指向的目标位置($target$，同世界坐标下)和$viewUp vector$<strong>三个参数</strong>。</p><ol><li>首先计算相机镜头方向$forward = target - eye$，并进行标准化：<script type="math/tex; mode=display">forward = \frac{forward}{\left \| forward \right \|}</script></li><li>根据$view-up vector$和$forward$确定相机的$side$向量:<script type="math/tex; mode=display">viewUp = \frac{viewUp}{\left \| viewUp \right \|}</script><script type="math/tex; mode=display">side = forward \times viewUp</script></li><li>根据$forward$和$side$计算$up$向量:<script type="math/tex; mode=display">up = side \times forward</script><blockquote><p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。</p></blockquote></li></ol><p>这样$eye$位置，以及$forward$、$side$、$up$三个基向量构成一个新的坐标系，注意这个坐标系是一个左手坐标系，因此在实际使用中，需要对$forward$进行一个翻转。</p><p>利用$-forward$、$side$、$up$和$eye$来构成一个右手坐标系。</p><p>我们的目标是<strong>计算世界坐标系中的物体在相机坐标系下的坐标</strong>，也就是从相机的角度来解释物体的坐标。从一个坐标系的坐标变换到另一个坐标系，这就是不同坐标系间坐标转换的过程。</p><h3 id="世界到相机的坐标变换"><a href="#世界到相机的坐标变换" class="headerlink" title="世界到相机的坐标变换"></a>世界到相机的坐标变换</h3><h4 id="计算方法1——直接计算变换矩阵"><a href="#计算方法1——直接计算变换矩阵" class="headerlink" title="计算方法1——直接计算变换矩阵"></a>计算方法1——直接计算变换矩阵</h4><p>要实现不同坐标系之间的坐标转换，需要求取一个变换矩阵。而这个矩阵就是一个坐标系A中的原点和基在另一个坐标系B下的表示。<br>我们将相机坐标系的原点和基，使用世界坐标系表示为($s$代表$side$基向量，$u$代表$up$基向量，$f$代表$forward$基向量)：</p><script type="math/tex; mode=display">(Camera)_{world} = \begin{bmatrix}s[0] &u[0] &-f[0] &eye_x \\ s[1] &u[1] &-f[1] &eye_y \\ s[2]& u[2] &-f[2] &eye_z\\ 0 & 0 & 0 & 1\end{bmatrix}</script><p>现在要求取的是坐标从世界坐标系变换到相机坐标系，则计算点p在相机坐标系下表示为：</p><script type="math/tex; mode=display">[p]_{camera} = [World]_{camera}[p]_{world} = [Camera]_{world}^{-1}[p]_{world} = view[p]_{world}</script><p>即求得视变换矩阵为:</p><script type="math/tex; mode=display">\begin{split} view  & =  [Camera]_{world}^{-1}\\\\  & = \begin{bmatrix}s[0] &s[1] &s[2] &-dot(s,eye) \\ u[0] &u[1] &u[2] &-dot(u,eye) \\ -f[0]& -f[1] &-f[2] &dot(f,eye)\\ 0 & 0 & 0 & 1\end{bmatrix}  \end{split}</script><p>上面计算逆矩阵的过程中使用到了分块矩阵求逆矩阵的定理：<br>设方阵$A,D$可逆，那么分块矩阵<script type="math/tex">\begin{pmatrix}A & B\\ 0 & D\end{pmatrix}</script><br>可逆，且其可逆矩阵为：</p><script type="math/tex; mode=display">T_{-1} = \begin{pmatrix}A^{-1} & -A^{-1}BD^{-1}\\ 0 & D^{-1}\end{pmatrix}</script><p>这种方式对应的计算代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动构造LookAt矩阵 方式1</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">computeLookAtMatrix1</span><span class="params">(glm::vec3 eye, glm::vec3 target, glm::vec3 viewUp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::vec3 f = glm::normalize(target - eye); <span class="comment">// forward vector</span></span><br><span class="line">    glm::vec3 s = glm::normalize(glm::cross(f, viewUp)); <span class="comment">// side vector</span></span><br><span class="line">    glm::vec3 u = glm::normalize(glm::cross(s, f)); <span class="comment">// up vector</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">lookAtMat</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(s.x, u.x, -f.x, <span class="number">0.0</span>), <span class="comment">// 第一列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(s.y, u.y, -f.y, <span class="number">0.0</span>), <span class="comment">// 第二列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(s.z, u.z, -f.z, <span class="number">0.0</span>), <span class="comment">// 第三列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    glm::vec4(-glm::dot(s, eye),-glm::dot(u, eye), glm::dot(f, eye), <span class="number">1.0</span>)  <span class="comment">// 第四列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> lookAtMat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方式求取过程中涉及到了分块矩阵的逆矩阵计算，如果不习惯，可以看下面的方式2，这是比较常用的方式。</p><h4 id="计算方法2——利用旋转和平移矩阵求逆矩阵"><a href="#计算方法2——利用旋转和平移矩阵求逆矩阵" class="headerlink" title="计算方法2——利用旋转和平移矩阵求逆矩阵"></a>计算方法2——利用旋转和平移矩阵求逆矩阵</h4><p>求取坐标转换矩阵的过程，也可以从另外一个角度出发，即将世界坐标系旋转和平移至于相机坐标系重合，这样这个旋转$R$和平移$T$矩阵的组合矩阵$M=T∗R$，就是将相机坐标系中坐标变换到世界坐标系中坐标的变换矩阵，那么所求的视变换矩阵（世界坐标系中坐标转换到相机坐标系中坐标的矩阵）$view=M−1$.<br>其中$R$就是上面求得的$side$、$up$、$forward$基向量构成的矩阵，如下：</p><script type="math/tex; mode=display">R = \begin{bmatrix}s[0] &u[0] &-f[2] &0 \\ s[1] &u[1] &-f[1] &0 \\ s[2]& u[2] &-f[2] &0\\ 0 & 0 & 0 & 1\end{bmatrix}</script><script type="math/tex; mode=display">T =  \begin{bmatrix}0 &0 &0 &eye_x \\ 0 &0 &0 &eye_y \\ 0& 0&0 &eye_z\\ 0 & 0 & 0 & 1\end{bmatrix}</script><p>那么所求的矩阵$view$计算过程如下:</p><script type="math/tex; mode=display">view = (T*R)^{-1} = R^{-1}*T^{-1}</script><p>在计算过程中，使用到了旋转矩阵的性质，即旋转矩阵是正交矩阵，它的逆矩阵等于矩阵的转置。<br>因此所求的:</p><script type="math/tex; mode=display">R^{-1} = \begin{bmatrix}s[0] &s[1] &s[2] &0 \\ u[0] &u[1] &u[2] &0 \\ -f[0]& -f[1] &-f[2] &0\\ 0 & 0 & 0 & 1\end{bmatrix}</script><script type="math/tex; mode=display">T^{-1} =  \begin{bmatrix}0 &0 &0 &-eye_x \\ 0 &0 &0 &-eye_y \\ 0& 0&0 &-eye_z\\ 0 & 0 & 0 & 1\end{bmatrix}</script><p>同样计算得到的视变换矩阵为：</p><script type="math/tex; mode=display">\begin{split} view  & = R_{T}*T_{-1}\\\\  & = \begin{bmatrix}s[0] &s[1] &s[2] &-dot(s,eye) \\ u[0] &u[1] &u[2] &-dot(u,eye) \\ -f[0]& -f[1] &-f[2] &dot(f,eye)\\ 0 & 0 & 0 & 1\end{bmatrix}  \end{split}</script><p>这种方式对应的计算代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 手动构造LookAt矩阵 方式2</span></span><br><span class="line"><span class="function">glm::mat4 <span class="title">computeLookAtMatrix2</span><span class="params">(glm::vec3 eye, glm::vec3 target, glm::vec3 viewUp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    glm::vec3 f = glm::normalize(target - eye); <span class="comment">// forward vector</span></span><br><span class="line">    glm::vec3 s = glm::normalize(glm::cross(f, viewUp)); <span class="comment">// side vector</span></span><br><span class="line">    glm::vec3 u = glm::normalize(glm::cross(s, f)); <span class="comment">// up vector</span></span><br><span class="line">    <span class="function">glm::mat4 <span class="title">rotate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(s.x, u.x, -f.x, <span class="number">0.0</span>), <span class="comment">// 第一列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(s.y, u.y, -f.y, <span class="number">0.0</span>), <span class="comment">// 第二列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(s.z, u.z, -f.z, <span class="number">0.0</span>), <span class="comment">// 第三列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        glm::vec4(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)  <span class="comment">//  第四列</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>;</span><br><span class="line">    glm::mat4  translate;</span><br><span class="line">    translate = glm::translate(translate, -eye);</span><br><span class="line">    <span class="keyword">return</span> rotate * translate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="建构改变基的矩阵"><a href="#建构改变基的矩阵" class="headerlink" title="建构改变基的矩阵"></a>建构改变基的矩阵</h2><p>想必读到这会对上面变基的矩阵感到迷糊，为什么另一个坐标空间的基坐标就是旋转坐标了呢。接下来我们对这部分的数学展开说说。</p><p>在游戏和计算机图形学里，经常把物体的位置、定向和缩放从某个坐标系转换至另一个坐标系。我们称此运算为基的变更。</p><p>坐标系是相对的。即是说，若想在三维空间中定义一组轴，必须指明其位置、定向和缩放的数值是相对于另外一组轴的（否则那些数值是没有意义的）。我们定义的其他空间直接或间接的相对于世界空间。</p><p>首先我们提出一个结论：<strong>线性变换由基及变换后基的值唯一确定，通过计算线性变换后基的值可以得到线性变换对应的矩阵A。</strong></p><p>定理：设$u_1,u_2,···,u_n$是线性空间$U$的一个基，线性空间$V$包含向量$v_1,v_2,···,v_n$(可以相同)。那么存在唯一的线性变换$T:U\rightarrow V$使得：$T(u_i) = v_i(1\leqslant i\leqslant n)$.</p><p>这个定理告诉我们: 只要知道了线性空间$U$的给定基$u_1,u_2,⋯,u_n$在线性变换$T$下对应的值$T(u_1),T(u_2),⋯,T(u_n)$，线性变换$T$也就由$u_i$及$T(u_i)$的对应关系确定了。<br>这个定理的作用就好比，两点确定一条直线。因此我们可以通过计算:<br>$A=(T(u_1),T(u_2),⋯,T(u_n))$来获取线性变换$T$对应的矩阵$A$。</p><p>也就是说，矩阵$A$的列向量，由$T(u_i)$在基$u_1,u_2,⋯,u_n$下的坐标唯一确定。同时给出一个矩阵$A$作为线性变换$T$在基$u_1,u_2,⋯,u_n$下的矩阵，也就给出了该基在线性变换T下对应的值$T(u_1),T(u_2),⋯,T(u_n)$，从而确定了线性变换$T$。这表明线性变换$T$与矩阵之间存在一一对应关系，上面已经证明了这个结论。</p><p>例如对于绕z轴旋转矩阵，从基和转换后基的角度，也就是从$x,y$轴来看，$x$转换后为$x′$，$y$转换后为$y′$，如下图所示:</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/6.png)</center><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/7.png)</center>因此可以顺利的写出旋转矩阵为:$$R(\theta) = \begin{bmatrix}cos\theta & -sin\theta\\ sin\theta & cos\theta\end{bmatrix}$$矩阵第一列即为$x$转换后的$x′$轴的对应的坐标，第二列即为$y$转换后的$y′$轴对应的坐标。显然这个计算方法，比利用极坐标公式来得快。在后面使用OpenGL模型变换矩阵时，经常要使用到这个方法，理解了这一点后面理解模型变换矩阵就会变得简单。## OpenGL中视变换的实现在OpenGL中，我们可以通过函数glm::lookAt来实现相机指定，这个函数计算的就是上面求出的视变换矩阵。以前glu版本实现为gluLookAt，这两个函数完成的功能是一样的，参数定义如下：API lookAt ( GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ)其中$eye$指定相机位置，$center$指定相机指向目标位置$target$，$up$指定$viewUp$向量。还记得之前的那个问题吗，初始时，相机镜头指向-z轴，要观察-z轴上的一个立方体的右侧面，我们可以怎么设置我们的lookat矩阵呢?<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/8.png)</center><p>默认情况下相机位于$(0,0,0)$，指向$-z$轴，对应$eye = (0,0,0), center = (0,0,-1), up = (0,1,0)$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::lookAt(glm::vec(<span class="number">0.0f</span>,<span class="number">0.0f</span>,<span class="number">0.0f</span>),</span><br><span class="line">            glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>),</span><br><span class="line">            glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><br>第一种方式，相机绕着+y轴旋转90度，相机指向-x轴，则等价于$eye = (0,0,0), center = (-1,0,0), up = (0,1,0)$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view &#x3D;glm::lookAt(glm::vec(0.0f,0.0f,0.0f),</span><br><span class="line">                            glm::vec3(-1.0f, 0.0f, 0.0f),</span><br><span class="line">                            glm::vec3(0.0f, 1.0f, 0.0f));</span><br></pre></td></tr></table></figure><br>上述第二种方式，通过立方体绕着+y轴旋转-90度，则得到的矩阵M,相当于:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::rotate(glm::mat4(<span class="number">1.0</span>), glm::radians(<span class="number">-90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>));</span><br></pre></td></tr></table></figure></p><p>这里得到的矩阵M和上面的矩阵view是相同的，可以自行验证下。也就是说，通过旋转相机+y轴90度，和旋转立方体+y轴-90度，最终计算得到的矩阵相同。调整相机来得到观察效果，可以通过相应的方式来调整物体达到相同的效果。在OpenGL中并不存在真正的相机，这只是一个虚构的概念。</p><h2 id="视角"><a href="#视角" class="headerlink" title="视角"></a>视角</h2><p><code>glm::LookAt</code>函数需要一个<code>位置</code>、<code>目标</code>和<code>上向量</code>。它会创建一个和在上一节使用的一样的观察矩阵。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view;</span><br><span class="line">view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>), </span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), </span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><br>一般我们不改动上向量（其实不是真正最后观察坐标中的上向量，我们计算右向量使用的那个上向量）。我们可以改动位置和目标，改动位置得到的是从不同位置看向目标时看到的结果（一般我们是走进走远或者左右走动，也对应着z轴和x轴，不怎么会用到y轴）。而改动目标则可以模拟在同一个位置看向不同方向得到的结果。打个比方，好比有个房子在原地，修改位置是你在不同的位置看同一点，修改目标是你站在那里扫视它（一般我们就是左右看（绕y轴），上下看（绕x轴），也就是偏航角和俯仰角）。</p><p>这里我们再详细讨论一下如何修改lookat矩阵达到自由转换视角。具体实现可以参考教程1.7。</p><p>截至目前我们使用的都是欧拉角，其实对于理论逻辑/底层计算来讲，都应该使用四元数而并非欧拉角，因为欧拉角会出现<code>万向节死锁</code>。<a href="https://blog.csdn.net/Jaihk662/article/details/106519595">这里</a>有个详细的例子。</p><p>不过以下还是基于欧拉角进行讨论。我们已经知道了三种欧拉角。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/9.png)</center><ul><li><strong>俯仰角(Pitch)</strong>：沿x轴旋转的角，从上往下看的角</li><li><strong>偏航角(Yaw)</strong>：沿y轴旋转的角，从左往右看的角</li><li><strong>滚转角(Roll)</strong>：沿z轴旋转的角（对于摄像机而言，一般不关心这个）</li></ul><p>在观察空间我们一般只用到俯仰角和偏航角。可以理解毕竟滚转角相当于我们让摄像机头绕镜头旋转，不是常规操作。</p><p>关于坐标轴：</p><ul><li><strong>自身坐标系</strong>：物体自身的坐标轴，显然如果物体进行了俯仰、偏航、滚筒的旋转操作，那么坐标轴方向也会被改变</li><li><strong>世界坐标系</strong>：和物体无关，用来描述物体在世界中的位置，有唯一的原点和轴向</li><li><strong>惯性坐标系</strong>：自身坐标系到世界坐标系的过渡，原点为对应物体的原点，会随物体的移动而改变，轴向和世界坐标系的轴向一致，不会因为物体的旋转操作而改变</li></ul><p>我们假设一个物体的位置是$(5, 6, 15)$，欧拉角是$({50}^{\circ}, {30}^{\circ}, {70}^{\circ})$:</p><ul><li><strong>对于物体移动，从(0, 0, 0)到(5, 6, 15)，按照世界坐标/惯性坐标的轴向移动</strong>：顺序无关，也就说按照(0, 0, 0) ; (5, 0, 0) ; (5, 6, 0) ; (5, 6, 15)的方式移动和按照(0, 0, 0);  (0, 6, 0) ; (0, 6, 15) ; (5, 6, 15)的方式移动不会影响物体的最终位置</li><li><strong>对于物体移动，从(0, 0, 0)到(5, 6, 15)，按照自身轴向移动</strong>：顺序无关，同上，毕竟移动并不会改变自身坐标轴的朝向</li><li><strong>对于物体旋转，从(0, 0, 0)到</strong>$({50}^{\circ}, {30}^{\circ}, {70}^{\circ})$，按照世界坐标/惯性坐标的轴向旋转：顺序有关！</li><li><strong>对于物体旋转，从(0, 0, 0)到</strong>$({50}^{\circ}, {30}^{\circ}, {70}^{\circ})$，按照自身坐标系轴向旋转：顺序有关，同上，这个就很明显了，因为你每次旋转都会导致坐标轴同时发生改变。</li></ul><p>看的出来涉及到视角还是比较复杂的，光光一个欧拉角我们是无法定义物体最后的状态的，我们要确定好旋转次序和轴。</p><p>LookAt里面有3个属性，摄像机位置，目标位置和世界上向量，改变摄像机视角的方法正是改变这个目标位置。换句话说，我们其实在确定摄像机坐标系中的z轴。我们在世界坐标系中定义它。那么这个目标位置我们又怎么和欧拉角联系到一起呢。</p><p>这部分我目前还不是很清楚，等后续再来补充。目前的理解是通过定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos   = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br><span class="line">view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure><br>令鼠标左右上下代表着偏转角和俯仰角，相当于是在利用两个欧拉角定义世界坐标系（也能认为是惯性坐标系下）得到的方向向量。</p><h1 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h1><p>投影变换通过指定视见体(viewing frustum)来决定场景中哪些物体将可能会呈现在屏幕上。在视见体中的物体会出现在投影平面上，而在视见体之外的物体不会出现在投影平面上。投影包括很多类型，OpenGL中主要考虑透视投影(perspective projection)和正交投影( orthographic projection)。两者之间存在很大的区别，如下图所示(图片来自Modern OpenGL)：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/10.png)</center><p>上面的图中，红色和黄色球在视见体内，因而呈现在投影平面上，而绿色球在视见体外，没有在投影平面上成像。</p><p>指定视见体通过$(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)$6个参数来指定。注意在相机坐标系下，相机指向-z轴，nearVal和farVal表示的剪裁平面分别为:近裁剪平面$z=−nearVal$，以及远裁剪平面$z=−farVal$。推导投影矩阵，就要利用这6个参数。<strong>在OpenGL中成像是在近裁剪平面上完成。</strong></p><h2 id="透视投影矩阵的推导"><a href="#透视投影矩阵的推导" class="headerlink" title="透视投影矩阵的推导:"></a>透视投影矩阵的推导:</h2><p>透视投影中，相机坐标系中点被映射到一个标准立方体中，即规范化设备坐标系中，其中$[l,r]$映射到$[−1,1]$，$[b,t]$映射到$[-1,1]$中，以及$[n,f]$被映射到$[−1,1]$，如下图所示：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/11.png)</center><blockquote><p>注意到上面的相机坐标系为右手系，而NDC中+z轴向内，为左手系。</p></blockquote><h3 id="我们的目标"><a href="#我们的目标" class="headerlink" title="我们的目标"></a>我们的目标</h3><p>求出投影矩阵的目标就是要找到一个透视投影矩阵P使得下式成立：</p><script type="math/tex; mode=display">\begin{bmatrix}x_c\\ y_c\\ z_c\\ w_c\end{bmatrix} = P \ast \begin{bmatrix}x_e\\ y_e\\ z_e\\ w_e\end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix}x_n\\ y_n\\ z_n\end{bmatrix} = \begin{bmatrix}x_c/w_c\\ y_c/w_c\\ z_c/w_c\end{bmatrix}</script><p>上面的除以$w_clip$过程被称为透视除法，要找到我们需要的矩阵P，我们需要利用两个关系:</p><ul><li>投影位置$x_p$,$y_p$和相机坐标系中点$x_e$,$y_e$之间关系。投影后对于z分量都是$z_{p}=-nearVal$。</li><li>利用$x_p$，$y_p$和 $x_{ndc}$，$y_{ndc}$ 关系求出$x_{clip}$,$y_{clip}$。</li><li>利用$z_n$与$z_e$关系得出$z_{clip}$</li></ul><blockquote><p>以上用到了几个注脚，其中e指代eye(观察坐标)，c指代clip(裁剪坐标)。p指代projection(投影坐标)，ndc指代标准设备坐标系。我们的目标就是将相机坐标系中点$(x_e,y_e,z_e)$映射到一个标准立方体$(x_{ndc},y_{ndc},z_{ndc})$中。</p></blockquote><h3 id="计算投影平面上的位置"><a href="#计算投影平面上的位置" class="headerlink" title="计算投影平面上的位置"></a>计算投影平面上的位置</h3><p>投影时原先位于相机坐标系中的点$p=(x_e,y_e,z_e)$投影到投影平面后，得到点$p′=(x_p,y_p,−nearVal)$。具体过程如下图所示:</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/12.png)</center><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/13.png)</center><p>需要空间想象一下，可以得出左边的图是俯视图，右边是侧视图。利用三角形的相似性，通过俯视图可以得到$\frac{x_p}{x_e} = \frac{-n}{z_e}$，即：</p><script type="math/tex; mode=display">x_p = -\frac{nx_e}{z_e}</script><p>同理通过侧视图可以得到：</p><script type="math/tex; mode=display">y_p =- \frac{ny_e}{z_e}</script><p>可以发现他们都除以了$-z_e$这个量，并且与之成反比。再结合我们对于透视除法的理解，我们应当令$w_c = -z_e$，相应矩阵P的形式如下：</p><script type="math/tex; mode=display">\begin{bmatrix}x_c\\ y_c\\ z_c\\ w_c\end{bmatrix} = \begin{bmatrix}. & . & . &. \\ . & . &.  &. \\  .& . & . &. \\ 0 & 0 & -1 & 0\end{bmatrix} \ast \begin{bmatrix}x_e\\ y_e\\ z_e\\ w_e\end{bmatrix}</script><p>下面利用投影点和规范化设备坐标的关系计算出矩阵P的前面两行。</p><p>对于投影平面上$ x_p$满足 $[l,r]$线性映射到$ [−1,1]$对于 $y_p$满足 $[b,t]$线性映射到 $[−1,1]$。根据图可以得到线性关系。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/14.png)</center><p>再结合上面算出的$x_p = -\frac{nx_e}{z_e}$和$y_p =- \frac{ny_e}{z_e}$，代入提取可以得到：</p><script type="math/tex; mode=display">x_n = \frac{(\frac{2x_en}{r-l}+\frac{r+l}{r-l} \ast z_e)}{-z_e}</script><script type="math/tex; mode=display">y_n = \frac{(\frac{2y_en}{t-b}+\frac{t+b}{t-b} \ast z_e)}{-z_e}</script><p>相应的我们可以得到裁剪坐标（看上面我们的目标出可知，矩阵是直接相乘的，透视除法其实是顶点着色器自动完成的所以矩阵得到的是裁剪坐标）。</p><script type="math/tex; mode=display">x_c = \frac{2n}{r-l}x_e+\frac{r+l}{r-l} \ast z_e</script><script type="math/tex; mode=display">y_c = \frac{2n}{t-b}y_e+\frac{t+b}{t-b} \ast z_e</script><p>再次完善我们的投影矩阵P得到：</p><script type="math/tex; mode=display">\begin{bmatrix}x_c\\ y_c\\ z_c\\ w_c\end{bmatrix} = \begin{bmatrix}\frac{2n}{r-l} &0 & \frac{r+l}{r-l} &0 \\ 0 & \frac{2n}{t-b} &\frac{t+b}{t-b} &0 \\  0& 0 & A &B \\ 0 & 0 & -1 & 0\end{bmatrix} \ast \begin{bmatrix}x_e\\ y_e\\ z_e\\ w_e\end{bmatrix}</script><p>由于$z_e$投影到平面时结果都为$−n$，因此寻找$z_n$与之前的$x$,$y$分量不太一样。我们知道$z_n$与$x$,$y$分量无关，所以在上面的矩阵我们令$z_c = Az_e+Bw_e(z_n = \frac{Az_e+Bw_e}{-z_e})$，又观察坐标系中$w_e=1$，所以我们有：</p><script type="math/tex; mode=display">z_n = \frac{Az_e+B}{-z_e}</script><p>要求出系数A,B则，利用$z_n$与$z_e$的映射关系为：$(-n,-1)$和$(-f,1)$，像上面一样写线性关系式(两点式，上面是用的点斜式)可以得到：</p><script type="math/tex; mode=display">z_n = \frac{-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n}}{-z_e}</script><p>即可得到A和B。代入可得完整的矩阵P的形式为：</p><script type="math/tex; mode=display">P = \begin{bmatrix}\frac{2n}{r-l} &0 & \frac{r+l}{r-l} &0 \\ 0 & \frac{2n}{t-b} &\frac{t+b}{t-b} &0 \\  0& 0 & -\frac{f+n}{f-n} &-\frac{2fn}{f-n}\\ 0 & 0 & -1 & 0\end{bmatrix}</script><p>上述矩阵时一般的视见体矩阵，如果视见体是对称的，即满足$r=−l,t=−b$，则矩阵$P$可以简化为：</p><script type="math/tex; mode=display">P = \begin{bmatrix}\frac{n}{r} &0 &0 &0 \\ 0 & \frac{n}{t} &0 &0 \\  0& 0 & -\frac{f+n}{f-n} &-\frac{2fn}{f-n}\\ 0 & 0 & -1 & 0\end{bmatrix}</script><h3 id="Zfighting问题"><a href="#Zfighting问题" class="headerlink" title="Zfighting问题"></a>Zfighting问题</h3><p>根据上面</p><script type="math/tex; mode=display">z_n = \frac{-\frac{f+n}{f-n}z_e-\frac{2fn}{f-n}}{-z_e}</script><p>这是一个非线性关系函数，作图如下：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/15.png)</center>从左边图我们可以看到，在近裁剪平面附近$z_n$值变化比较大，精确度较好；而在远裁剪平面附近，有一段距离内，$z_n$近乎持平，精确度不好。当增大远近裁剪平面的范围$[−n,−f]$后，如右边图所示，我们看到在远裁剪平面附近，不同相机坐标$z_e$对应的$z_n$相同，精确度低的现象更为明显，这种深度的精确度引起的问题称之为zFighting。要尽量减小$[-n,-f]$的范围，以减轻zFighting问题。### gluPerspective以上指定视见体通过$(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble nearVal, GLdouble farVal)$6个参数来指定，另外一种经常使用的方式是通过 **视角(Fov)，宽高比(Aspect)**来指定透视投影，例如旧版中函数`gluPerspective`,也是我们用到的教程中的：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//API void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);</span></span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)screenWidth/(<span class="keyword">float</span>)screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure>其中指定fovy指定视角，aspect指定宽高比，zNear和zFar指定剪裁平面。fovy的理解如下图所示([来自opengl 投影](http://www.gimoo.net/t/1507/55a62113251f2.html))：<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/16.png)</center>这些参数指定的是一个对称的视见体，如下图所示：<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/17.png)</center><p>由这些参数，可以得到：</p><script type="math/tex; mode=display">h = near \ast tan(\frac{\theta}{2})</script><script type="math/tex; mode=display">w = h \ast aspect</script><p>再对应到上面公式里需要的6个参数，后两个不变，前四个对应为：</p><script type="math/tex; mode=display">r = w, l = -r</script><script type="math/tex; mode=display">t = h, b=-t</script><p>则得到<code>Fov透视投影矩阵</code>为：</p><script type="math/tex; mode=display">P = \begin{bmatrix}\frac{1}{aspect \cdot tan(\frac{\theta}{2})} &0 &0 &0 \\ 0 &\frac{1}{tan(\frac{\theta}{2})} &0 &0 \\  0& 0 & -\frac{f+n}{f-n} &-\frac{2fn}{f-n}\\ 0 & 0 & -1 & 0\end{bmatrix}</script><h2 id="正交投影矩阵的推导"><a href="#正交投影矩阵的推导" class="headerlink" title="正交投影矩阵的推导"></a>正交投影矩阵的推导</h2><p>相比于透视投影，正交投影矩阵的推导要简单些，如下图所示：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/18.png)</center><p>对于正交投影，有$x_p=x_e,y_p=y_e$，因而可以直接利用$x_e$与$x_n$的映射关系：$[l,−1],[r,1]$，利用$y_e$和$y_n$的映射关系：$[b,−1],[t,1]$，以及$z_e$和$z_n$的映射关系：$[−n,−1],[−f,1]$。得到：</p><script type="math/tex; mode=display">x_n = \frac{2}{r-l}x_e-\frac{r+l}{r-l}</script><script type="math/tex; mode=display">y_n =\frac{2}{t-b}y_e-\frac{t+b}{t-b}</script><script type="math/tex; mode=display">z_n =\frac{-2}{f-n}z_e-\frac{f+n}{f-n}</script><p>对于正交投影而言，$w$成分是不必要的，保持为1即可，则所求投影矩阵第四行为$(0,0,0,1)$，$w$保持为1，则NDC坐标和剪裁坐标相同，从而得到正交投影矩阵为:</p><script type="math/tex; mode=display">O = \begin{bmatrix}\frac{2}{r-l} &0 &0 &-\frac{r+l}{r-l}  \\ 0 &\frac{2}{t-b} &0 &-\frac{t+b}{t-b}  \\  0& 0 & -\frac{2}{f-n} &-\frac{f+n}{f-n}\\ 0 & 0 &0 & 1\end{bmatrix}</script><p>还可以看做把视见体的中心移动到规范视见体的中心即原点处，然后缩放视见体使得它的每条边长度都为2，进行这一过程的变换表示为：</p><script type="math/tex; mode=display">O= \begin{bmatrix}\frac{2}{r-l} &0 &0 &0 \\ 0 &\frac{2}{t-b} &0 &0 \\  0& 0 & \frac{2}{n-f} &0\\ 0 & 0 &0 & 1\end{bmatrix} \ast \begin{bmatrix}1 &0 &0 &-\frac{r+l}{2} \\ 0 &1&0 &-\frac{t+b}{2}  \\  0& 0 &1 &-\frac{f+n}{2}\\ 0 & 0 &0 & 1\end{bmatrix}</script><p>如果视见体是对称的，即满足r=−l,t=−b，则矩阵O可以简化为：</p><script type="math/tex; mode=display">O = \begin{bmatrix}\frac{1}{r} &0 &0 &0  \\ 0 &\frac{1}{t} &0 &0 \\  0& 0 & -\frac{2}{f-n} &-\frac{f+n}{f-n}\\ 0 & 0 &0 & 1\end{bmatrix}</script><h1 id="视口变换矩阵"><a href="#视口变换矩阵" class="headerlink" title="视口变换矩阵"></a>视口变换矩阵</h1><p>经过上述的投影变换，我们已经将观察坐标$(x_e,y_e,z_e)$变换成了NDC坐标$(x_n,y_n,z_n)$，视变换是将NDC坐标转换为显示屏幕坐标的过程，如下图所示：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6.2/19.png)</center><p>视口变化通过函数:<br><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtmlhttps://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml">glViewport(GLint , GLint , GLsizei , GLsizei );</a><br><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glViewport.xhtml">glDepthRangef(GLclampf , GLclampf );</a></p><p>两个函数来指定。其中$(s_x,s_y)$表示窗口的左下角，$n_s$和$f_s$指定远近剪裁平面到屏幕坐标的映射关系。<br>使用线性映射关系如下：</p><script type="math/tex; mode=display">x:(-1,s_x),(1,s_x+w_s)</script><script type="math/tex; mode=display">y:(-1,s_y),(1,s_y+h_s)</script><script type="math/tex; mode=display">y:(-1,n_s),(1,f_s)</script><p>求出线性映射函数为:</p><script type="math/tex; mode=display">x_s = \frac{w_s}{2}x_n + s_x + \frac{w_s}{2}</script><script type="math/tex; mode=display">y_s = \frac{h_s}{2}y_n + s_y + \frac{h_s}{2}</script><script type="math/tex; mode=display">z_s = \frac{f_s - n_s}{2}z_n  + \frac{n_s + f_s}{2}</script><p>则由上述式子得到视口变换矩阵为：</p><script type="math/tex; mode=display">viewPort = \begin{bmatrix}\frac{w_s}{2} &0 &0 &s_x + \frac{w_s}{2}  \\ 0 &\frac{h_s}{2} &0 &s_y + \frac{h_s}{2} \\  0& 0 & \frac{f_s - n_s}{2} &\frac{n_s + f_s}{2}\\ 0 & 0 &0 & 1\end{bmatrix}</script>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记1.6-坐标系统</title>
    <link href="https://idinghy.com/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-6-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
    <id>https://idinghy.com/2020/12/07/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-6-%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-12-07T12:26:00.000Z</published>
    <updated>2020-12-07T13:13:32.048Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>官方教程见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">这里</a></li><li>官方代码见<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/6.3.coordinate_systems_multiple/coordinate_systems_multiple.cpp">这里</a></li><li>投影矩阵推导搬移来自<a href="https://blog.csdn.net/wangdingqiaoit/article/details/51589825?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control">这里</a><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1>在上一个教程中，我们学习了如何有效地利用矩阵的变换来对所有顶点进行变换。OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的x，y，z坐标都应该在<strong>-1.0</strong>到<strong>1.0</strong>之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</li></ul><p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p><ul><li>局部空间(Local Space，或者称为物体空间(Object Space))</li><li>世界空间(World Space)</li><li>观察空间(View Space，或者称为视觉空间(Eye Space))</li><li>裁剪空间(Clip Space)</li><li>屏幕空间(Screen Space)</li></ul><p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p><h1 id="空间介绍"><a href="#空间介绍" class="headerlink" title="空间介绍"></a>空间介绍</h1><h2 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h2><p><code>局部空间</code>是指物体所在的坐标空间，即对象最开始所在的地方。想象你在一个建模软件（比如说Blender）中创建了一个立方体。你创建的立方体的原点有可能位于(0, 0, 0)，即便它有可能最后在程序中处于完全不同的位置。甚至有可能你创建的所有模型都以(0, 0, 0)为初始位置（译注：然而它们会最终出现在世界的不同位置）。所以，你的模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。</p><p>我们一直使用的那个箱子的顶点是被设定在-0.5到0.5的坐标范围中，(0, 0)是它的原点。这些都是局部坐标。</p><p>再比如我们定义一个在3D世界中的箱子，箱子上布了图片会是这样的坐标：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一个正方体是6个面，每个面进行纹理贴图。</p><h2 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h2><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。<code>世界空间</code>中的坐标正如其名：是指<strong>顶点相对于（游戏）世界的坐标</strong>。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由<code>模型矩阵(Model Matrix)</code>实现的。</p><p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。</p><p>举个例子模型矩阵长这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">model = glm::translate(model, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">model = glm::rotate(model, (<span class="keyword">float</span>)glfwGetTime() * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">model = glm::scale(model, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><br>注意顺序，先缩放然后旋转再位移。可以调整我们的物体在世界空间的状态。</p><h2 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h2><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是<strong>将世界空间坐标转化为用户视野前方的坐标</strong>而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个<code>观察矩阵(View Matrix)</code>里，它被用来将世界坐标变换到观察空间。</p><p>举个例子观察矩阵长这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">view = glm::translate(view, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br></pre></td></tr></table></figure><br>基于OpenGL是右手坐标系（z轴正方向指向我们），</p><blockquote><p>右手坐标系(Right-handed System)<br>照惯例，OpenGL是一个右手坐标系。简单来说，就是正x轴在你的右手边，正y轴朝上，而正z轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。</p></blockquote><p>坐标系画起来如下：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6/1.png)</center><p>我们让场景向z轴负方向(0.0f, 0.0f, -3.0f)动，也就是相当于远离我们（摄像机），造成一种我们在往后移动的感觉。对应一下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">模型移动方向</th><th style="text-align:left">操作</th></tr></thead><tbody><tr><td style="text-align:left">向左</td><td style="text-align:left">-x</td></tr><tr><td style="text-align:left">向右</td><td style="text-align:left">+x</td></tr><tr><td style="text-align:left">向上</td><td style="text-align:left">+y</td></tr><tr><td style="text-align:left">向下</td><td style="text-align:left">-y</td></tr><tr><td style="text-align:left">靠近</td><td style="text-align:left">+z</td></tr><tr><td style="text-align:left">远离</td><td style="text-align:left">-z</td></tr></tbody></table></div><h2 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h2><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是<code>裁剪空间(Clip Space)</code>名字的由来。</p><p>因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</p><p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个<code>投影矩阵(Projection Matrix)</code>，它<strong>指定了一个范围的坐标</strong>，比如在每个维度上的-1000到1000。投影矩阵接着会<strong>将在这个指定的范围内的坐标变换为标准化设备坐标的范围</strong>(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。</p><blockquote><p>如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。</p></blockquote><p>由投影矩阵创建的观察箱(Viewing Box)被称为<code>平截头体(Frustum)</code>，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为<strong>使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中</strong>。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作——<code>透视除法(Perspective Division)</code>将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是<strong>将4D裁剪空间坐标变换为3D标准化设备坐标</strong>的过程。<strong>这一步会在每一个顶点着色器运行的最后被自动执行。</strong></p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用<code>glViewport</code>中的设定），并被变换成片段。</p><p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。</p><h3 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h3><p>正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6/2.png)</center><p>上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标.</p><p>要创建一个正射投影矩阵，我们可以使用GLM的内置函数<code>glm::ortho</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::ortho(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><br>前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。</p><p>正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将<code>透视(Perspective)</code>考虑进去。所以我们需要透视投影矩阵来解决这个问题。</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>如果你曾经体验过实际生活给你带来的景象，你就会注意到离你越远的东西看起来更小。这个奇怪的效果称之为透视(Perspective)。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6/3.png)</center><p>正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：</p><script type="math/tex; mode=display"> out = \begin{pmatrix}x/w\\ y/w\\ z/w\end{pmatrix}</script><p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。<strong>这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。</strong>最后的结果坐标就是处于标准化设备空间中的。如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由Songho写的<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">文章</a>。</p><p>在GLM中可以这样创建一个透视投影矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 proj = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)width/(<span class="keyword">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>同样，glm::perspective所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6/4.png)</center><p>它的第一个参数定义了<code>fov</code>的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值。第二个参数设置了<code>宽高比</code>，由视口的宽除以高所得。第三和第四个参数设置了平截头体的<code>近和远平面</code>。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</p><blockquote><p>当你把透视矩阵的 near 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候你的视线会直接穿过去。(看不到它了)</p></blockquote><p>当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法（它仍然会进行透视除法，只是w分量没有被改变（它保持为1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在Blender里面使用两种投影方式的对比：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6/5.png)</center><p>你可以看到，使用透视投影的话，远处的顶点看起来比较小，而在正射投影中每个顶点距离观察者的距离都是一样的。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。我们的顶点坐标起始于局部空间(Local Space)，在这里它称为<code>局部坐标</code>(Local Coordinate)，它在之后会变为<code>世界坐标</code>(World Coordinate)，<code>观察坐标</code>(View Coordinate)，<code>裁剪坐标</code>(Clip Coordinate)，并最后以<code>屏幕坐标</code>(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.6/6.png)</center><ul><li>局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。</li><li>下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。</li><li>接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的。</li><li>坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上。</li><li>最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ul><p>我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。</p><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：</p><script type="math/tex; mode=display">V_{clip} = M_{projection} \cdot M_{view} \cdot M_{model} \cdot V_{local}</script><p>注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的<em>gl_Position</em>，OpenGL将会自动进行透视除法和裁剪。</p><blockquote><p>顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为视口变换。</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="Z缓冲"><a href="#Z缓冲" class="headerlink" title="Z缓冲"></a>Z缓冲</h2><p>因为OpenGL是一个三角形一个三角形地来绘制你的立方体的，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。观感会很奇怪。幸运的是，OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。通过使用Z缓冲，我们可以配置OpenGL来进行深度测试。</p><p>核心就是一句话，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class="comment">//渲染循环中</span></span><br></pre></td></tr></table></figure><br>OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。</p><p>然而，如果我们想要确定OpenGL真的执行了深度测试，首先我们要告诉OpenGL我们想要启用深度测试；它默认是关闭的。我们可以通过glEnable函数来开启深度测试。<code>glEnable</code>和<code>glDisable</code>函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启<em>GL_DEPTH_TEST</em>：</p><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = mix(texture(texture1, TexCoord), texture(texture2,TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个立方体旋转"><a href="#多个立方体旋转" class="headerlink" title="多个立方体旋转"></a>多个立方体旋转</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;./shader/vertex_3D_2.txt&quot;</span>, <span class="string">&quot;./shader/fragment_texture_2.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    glm::vec3 cubePositions[] = &#123;</span><br><span class="line">        glm::vec3(<span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>),</span><br><span class="line">        glm::vec3(<span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),</span><br><span class="line">        glm::vec3(<span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>),</span><br><span class="line">        glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// texture attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="keyword">float</span> borderColor[] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    stbi_set_flip_vertically_on_load(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">                                            <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = stbi_load(<span class="string">&quot;awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.use(); <span class="comment">// don&#x27;t forget to activate/use the shader before setting uniforms!</span></span><br><span class="line">                     <span class="comment">// either set it manually like so:</span></span><br><span class="line">    glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// or set it via the texture class</span></span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">        glActiveTexture(GL_TEXTURE1);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render container</span></span><br><span class="line">        ourShader.use();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//glm::mat4 model = glm::mat4(1.0f);</span></span><br><span class="line">        glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">        glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f));</span></span><br><span class="line">        <span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">        view = glm::translate(view, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));    </span><br><span class="line">        projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int viewLoc = glGetUniformLocation(ourShader.ID, &quot;view&quot;);</span></span><br><span class="line">        <span class="comment">//glUniformMatrix4fv(viewLoc, 1, GL_FALSE, &amp;view[0][0]);</span></span><br><span class="line">        ourShader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        <span class="comment">//int modelLoc = glGetUniformLocation(ourShader.ID, &quot;model&quot;);</span></span><br><span class="line">        <span class="comment">//glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));</span></span><br><span class="line">        <span class="comment">//ourShader.setMat4(&quot;model&quot;, model);</span></span><br><span class="line">        <span class="comment">//int projectionLoc = glGetUniformLocation(ourShader.ID, &quot;projection&quot;);</span></span><br><span class="line">        <span class="comment">//glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));</span></span><br><span class="line">        ourShader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">            model = glm::translate(model, cubePositions[i]);</span><br><span class="line">            <span class="keyword">float</span> angle = <span class="number">20.0f</span> * (i + <span class="number">1</span>) * (<span class="keyword">float</span>)glfwGetTime();</span><br><span class="line">            model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">            ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">            glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="矩阵参数修改效果"><a href="#矩阵参数修改效果" class="headerlink" title="矩阵参数修改效果"></a>矩阵参数修改效果</h3><p>用这个代码可以用按键控制参数的调整来观察效果。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> vec_view[<span class="number">3</span>] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-5.0f</span>&#125;;</span><br><span class="line"><span class="keyword">float</span> vec_projection[<span class="number">2</span>] = &#123; <span class="number">45.0f</span>, (<span class="keyword">float</span>)SCR_WIDTH / (<span class="keyword">float</span>)SCR_HEIGHT&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;./shader/vertex_3D_2.txt&quot;</span>, <span class="string">&quot;./shader/fragment_texture_2.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>, <span class="number">-2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">2.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-2.0f</span>,  <span class="number">2.0f</span>, <span class="number">-2.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// texture attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="keyword">float</span> borderColor[] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br><span class="line"></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    stbi_set_flip_vertically_on_load(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">                                            <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = stbi_load(<span class="string">&quot;awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.use(); <span class="comment">// don&#x27;t forget to activate/use the shader before setting uniforms!</span></span><br><span class="line">                     <span class="comment">// either set it manually like so:</span></span><br><span class="line">    glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// or set it via the texture class</span></span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glEnable(GL_DEPTH_TEST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">        glActiveTexture(GL_TEXTURE1);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render container</span></span><br><span class="line">        ourShader.use();</span><br><span class="line"></span><br><span class="line">        glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">        glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">        glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">        model = glm::translate(model, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        model = glm::rotate(model, (<span class="keyword">float</span>)glfwGetTime() * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">        model = glm::scale(model, glm::vec3(<span class="number">0.25</span>, <span class="number">0.25</span>, <span class="number">0.25</span>));</span><br><span class="line">        <span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动。</span></span><br><span class="line">        view = glm::translate(view, glm::vec3(vec_view[<span class="number">0</span>], vec_view[<span class="number">1</span>], vec_view[<span class="number">2</span>]));</span><br><span class="line">        </span><br><span class="line">        projection = glm::perspective(glm::radians(vec_projection[<span class="number">0</span>]), vec_projection[<span class="number">1</span>], <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//int viewLoc = glGetUniformLocation(ourShader.ID, &quot;view&quot;);</span></span><br><span class="line">        <span class="comment">//glUniformMatrix4fv(viewLoc, 1, GL_FALSE, &amp;view[0][0]);</span></span><br><span class="line">        ourShader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">        <span class="comment">//int modelLoc = glGetUniformLocation(ourShader.ID, &quot;model&quot;);</span></span><br><span class="line">        <span class="comment">//glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));</span></span><br><span class="line">        ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line">        <span class="comment">//int projectionLoc = glGetUniformLocation(ourShader.ID, &quot;projection&quot;);</span></span><br><span class="line">        <span class="comment">//glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));</span></span><br><span class="line">        ourShader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)</span><br><span class="line">        vec_view[<span class="number">1</span>] += <span class="number">0.001f</span>;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)</span><br><span class="line">        vec_view[<span class="number">1</span>] -= <span class="number">0.001f</span>;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)</span><br><span class="line">        vec_view[<span class="number">0</span>] -= <span class="number">0.001f</span>;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)</span><br><span class="line">        vec_view[<span class="number">0</span>] += <span class="number">0.001f</span>;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_1) == GLFW_PRESS)</span><br><span class="line">        vec_view[<span class="number">2</span>] += <span class="number">0.001f</span>;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_2) == GLFW_PRESS)</span><br><span class="line">        vec_view[<span class="number">2</span>] -= <span class="number">0.001f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fov</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_3) == GLFW_PRESS)</span><br><span class="line">        vec_projection[<span class="number">0</span>] -= <span class="number">0.001f</span>;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_4) == GLFW_PRESS)</span><br><span class="line">        vec_projection[<span class="number">0</span>] += <span class="number">0.001f</span>;</span><br><span class="line">    <span class="comment">//aspect_ratio</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_5) == GLFW_PRESS)</span><br><span class="line">        vec_projection[<span class="number">1</span>] -= <span class="number">1</span> / (<span class="keyword">float</span>)SCR_HEIGHT;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_6) == GLFW_PRESS)</span><br><span class="line">        vec_projection[<span class="number">1</span>] += <span class="number">1</span> / (<span class="keyword">float</span>)SCR_HEIGHT;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 写博客怎么加入LaTeX</title>
    <link href="https://idinghy.com/2020/12/02/Hexo-%E5%86%99%E5%8D%9A%E5%AE%A2%E6%80%8E%E4%B9%88%E5%8A%A0%E5%85%A5LaTeX/"/>
    <id>https://idinghy.com/2020/12/02/Hexo-%E5%86%99%E5%8D%9A%E5%AE%A2%E6%80%8E%E4%B9%88%E5%8A%A0%E5%85%A5LaTeX/</id>
    <published>2020-12-02T07:43:24.000Z</published>
    <updated>2020-12-02T08:21:02.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>如果你搜到了这篇文章，那么大概是你写博客的时候发现markdown输入latex公式结果原样输出了(丑陋)，或者你的公式消失了(闹心)。</p><h1 id="参考解决方式"><a href="#参考解决方式" class="headerlink" title="参考解决方式"></a>参考解决方式</h1><ul><li><a href="https://cps.ninja/2019/03/16/hexo-with-latex/">https://cps.ninja/2019/03/16/hexo-with-latex/</a></li><li><a href="https://www.jianshu.com/p/d95a4795f3a8">https://www.jianshu.com/p/d95a4795f3a8</a></li></ul><p>最后成功方式如下：</p><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装 hexo ； --save 参数会让 npm 在安装 hexo-math 之后自动将它写入 package.json 文件里，以便之后多电脑同步时使用</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-math --save</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 卸载默认 markdown 渲染引擎 hexo-renderer-marked；若不卸载，会和新的引擎发生冲突（conflict）</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall hexo-renderer-marked --save</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 安装新引擎 hexo-renderer-kramed </span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-kramed --save</span></span><br></pre></td></tr></table></figure><h2 id="修改-kramed-配置，解决语义冲突"><a href="#修改-kramed-配置，解决语义冲突" class="headerlink" title="修改 kramed 配置，解决语义冲突"></a>修改 kramed 配置，解决语义冲突</h2><p>由于 LaTeX 与 Markdown 语法存在冲突（例如在 markdown 中，斜体可以用 * 或者_ 表示，而 LaTeX 也会用到 _ ），所以我们要对 kramed 默认的语法规则进行修改，否则之后会出现很多奇怪的排版样式。<br>打开 ~/blog/node_modules\kramed\lib\rules\inline.js文件（Hexo 博客所在文件夹的根目录下的 node_modules 文件夹），修改第 11 行的 escape 变量的值和第 20 行的 em 变量:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// ~/blog/node_modules\kramed\lib\rules\inline.js</span><br><span class="line"></span><br><span class="line">var inline = &#123;</span><br><span class="line">  //escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,      // 注释掉的默认规则</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,            // 新增的规则</span><br><span class="line">  autolink: /^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/,</span><br><span class="line">  url: noop,</span><br><span class="line">  html: /^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:&quot;[^&quot;]*&quot;|&#x27;[^&#x27;]*&#x27;|[^&#x27;&quot;&gt;])*?&gt;/,</span><br><span class="line">  link: /^!?\[(inside)\]\(href\)/,</span><br><span class="line">  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,</span><br><span class="line">  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,</span><br><span class="line">  reffn: /^!?\[\^(inside)\]/,</span><br><span class="line">  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,</span><br><span class="line">  //em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,    // 注释掉的默认规则</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,                               // 新增的规则</span><br><span class="line">  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,</span><br><span class="line">  br: /^ &#123;2,&#125;\n(?!\s*$)/,</span><br><span class="line">  del: noop,</span><br><span class="line">  text: /^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/,</span><br><span class="line">  math: /^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//...</span><br></pre></td></tr></table></figure><h1 id="安装Mathjax"><a href="#安装Mathjax" class="headerlink" title="安装Mathjax"></a>安装Mathjax</h1><p>首先你要确认你的主题中是否使用了Mathjax, 最便捷的方法是看下你主题的Readme，然后按照说明开启Mathjx支持。一般完善的主题还会有一些额外的设置，例如需不需要对每个文章都开启Mathjax支持，或者更换CDN之类的，这些应该都可以在Readme里找到。</p><p>如果啥也没有，那么我们就要自己造轮子了。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>在themes/Your-Theme-Name/layout/下新建文件mathjax.ejs：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.mathjax.enable)&#123; %&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><br><span class="line">      MathJax.Hub.Config(&#123;</span><br><span class="line">          tex2jax: &#123;</span><br><span class="line">            inlineMath: [ [<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>], [<span class="string">&quot;\\(&quot;</span>,<span class="string">&quot;\\)&quot;</span>] ],</span><br><span class="line">            processEscapes: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><br><span class="line">      MathJax.Hub.Config(&#123;</span><br><span class="line">            tex2jax: &#123;</span><br><span class="line">              skipTags: [&#x27;script&#x27;, &#x27;noscript&#x27;, &#x27;style&#x27;, &#x27;textarea&#x27;, &#x27;pre&#x27;, &#x27;code&#x27;]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><br><span class="line">      MathJax.Hub.Queue(function() &#123;</span><br><span class="line">              var all = MathJax.Hub.getAllJax(), i;</span><br><span class="line">              <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; all.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">                  all[i].SourceElement().parentNode.className += &#x27; has-jax&#x27;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;&lt;%- theme.mathjax.cdn %&gt;&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>在<code>主题</code>的_config.yml文件末尾添加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  cdn: https:<span class="comment">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>修改themes/Your-Theme-Name/layout/post.ejs, 在文件的main标签块中加入(找类似有partial的块中并列加上)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.mathjax == <span class="literal">true</span>)&#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#x27;mathjax&#x27;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>在你需要写Latex的文章Markdown头部添加：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>到这里我们就自己添加了Mathjax。<strong>只会在文章头部有mathjax: true时，启用Mathjax</strong>。</p><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>markdown内写入（记得要在头部加入mathjax: true）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">  \begin&#123;split&#125;</span><br><span class="line">  \frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x_l&#125;&#125; &amp; = </span><br><span class="line">  \frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x_L&#125;&#125;\frac&#123;\partial&#123;x_L&#125;&#125;&#123;\partial&#123;x_l&#125;&#125;\\\\</span><br><span class="line">  &amp; = \frac&#123;\partial&#123;\mathcal&#123;E&#125;&#125;&#125;&#123;\partial&#123;x_L&#125;&#125;\Big(<span class="number">1</span>+\frac&#123;\partial&#123;&#125;&#125;&#123;\partial&#123;x_l&#125;&#125;\sum_&#123;i=l&#125;^&#123;L<span class="number">-1</span>&#125;   </span><br><span class="line">  \mathcal&#123;F&#125;(x_i,\mathcal&#123;W&#125;_i)\Big)</span><br><span class="line">  \end&#123;split&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><br>然后命令行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean;</span><br><span class="line">hexo d;</span><br><span class="line">hexo g;</span><br></pre></td></tr></table></figure><br>实验一下是不是能显示出：</p><script type="math/tex; mode=display">  \begin{split}  \frac{\partial{\mathcal{E}}}{\partial{x_l}} & =   \frac{\partial{\mathcal{E}}}{\partial{x_L}}\frac{\partial{x_L}}{\partial{x_l}}\\\\  & = \frac{\partial{\mathcal{E}}}{\partial{x_L}}\Big(1+\frac{\partial{}}{\partial{x_l}}\sum_{i=l}^{L-1}     \mathcal{F}(x_i,\mathcal{W}_i)\Big)  \end{split}</script>]]></content>
    
    
    <summary type="html">hexo搭建的博客怎么支持latex公式输入</summary>
    
    
    
    <category term="skill" scheme="https://idinghy.com/category/skill/"/>
    
    
    <category term="Website" scheme="https://idinghy.com/tag/Website/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记1.5-变换</title>
    <link href="https://idinghy.com/2020/12/02/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-5-%E5%8F%98%E6%8D%A2/"/>
    <id>https://idinghy.com/2020/12/02/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-5-%E5%8F%98%E6%8D%A2/</id>
    <published>2020-12-02T06:50:06.000Z</published>
    <updated>2020-12-07T12:22:40.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>官方教程见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/">这里</a></li><li>官方代码见<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/5.2.transformations_exercise2/transformations_exercise2.cpp">这里</a></li></ul><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>尽管我们现在已经知道了如何创建一个物体、着色、加入纹理，给它们一些细节的表现，但因为它们都还是静态的物体，仍是不够有趣。我们可以尝试着在每一帧改变物体的顶点并且重配置缓冲区从而使它们移动，但这太繁琐了，而且会消耗很多的处理时间。我们现在有一个更好的解决方案，使用（多个）矩阵(Matrix)对象可以更好的变换(Transform)一个物体。</p><p>在正式展开之前，需要自主理解几个概念：向量、矩阵、标量等。</p><h1 id="向量："><a href="#向量：" class="headerlink" title="向量："></a>向量：</h1><script type="math/tex; mode=display"> \vec{v} = \begin{pmatrix}x\\ y\\ z\end{pmatrix}</script><h2 id="向量长度："><a href="#向量长度：" class="headerlink" title="向量长度："></a>向量长度：</h2><script type="math/tex; mode=display">\left \| \vec{v} \right \| = \sqrt[2]{x^2 + y^2 +z^2}</script><h2 id="单位向量："><a href="#单位向量：" class="headerlink" title="单位向量："></a>单位向量：</h2><script type="math/tex; mode=display">\hat{n} = \frac{\vec{v}}{\left \| \vec{v} \right \|}</script><h2 id="点乘："><a href="#点乘：" class="headerlink" title="点乘："></a>点乘：</h2><p>使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）。</p><script type="math/tex; mode=display">\vec{v}\cdot \vec{k} = \left \| \vec{v} \right \| \cdot \left \| \vec{k} \right \| \cdot cos\theta = x_1x_2 + y_1y_2 + z_1z_2</script><h2 id="叉乘："><a href="#叉乘：" class="headerlink" title="叉乘："></a>叉乘：</h2><p>叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。</p><script type="math/tex; mode=display">\begin{pmatrix}A_x\\ A_y\\ A_z\end{pmatrix} \times \begin{pmatrix}B_x\\ B_y\\ B_z\end{pmatrix} = \begin{pmatrix}A_y\cdot B_z - A_z\cdot B_y\\ A_z\cdot B_x - A_x\cdot B_z\\ A_x\cdot B_y - A_y\cdot B_x\end{pmatrix}</script><h1 id="矩阵："><a href="#矩阵：" class="headerlink" title="矩阵："></a>矩阵：</h1><p>简单来说矩阵就是一个矩形的数字、符号或表达式数组。下面是一个2×3矩阵的例子：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 & 3\\ 4 & 5 & 6\end{bmatrix}</script><p>矩阵可以通过(i,jj)进行索引，i是行，j是列，这就是上面的矩阵叫做2×3矩阵的原因（3列2行，也叫做矩阵的维度(Dimension)）。这与你在索引2D图像时的(x, y)相反，获取4的索引是(2, 1)（第二行，第一列）（译注：如果是图像索引应该是(1, 2)，先算列，再算行）。</p><h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>矩阵之间的乘法不见得有多复杂，但的确很难让人适应。矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制：</p><ul><li>只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘，比如(m,n)矩阵乘(n,k)矩阵得到的结果会是(m,k)矩阵。其中n要两个矩阵一致。</li><li>矩阵相乘不遵守交换律(Commutative)，也就是说$A\cdot B \neq B\cdot A$。</li></ul><h2 id="矩阵与向量相乘"><a href="#矩阵与向量相乘" class="headerlink" title="矩阵与向量相乘"></a>矩阵与向量相乘</h2><p>我们用向量来表示位置，表示颜色，甚至是纹理坐标。让我们更深入了解一下向量，它其实就是一个N×1矩阵，N表示向量分量的个数（也叫N维(N-dimensional)向量）。如果你仔细思考一下就会明白。向量和矩阵一样都是一个数字序列，但它只有1列。那么，这个新的定义对我们有什么帮助呢？如果我们有一个M×N矩阵，我们可以用这个矩阵乘以我们的N×1向量，因为这个矩阵的列数等于向量的行数，所以它们就能相乘。在OpenGL中，由于某些原因我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。</p><p>很多有趣的2D/3D变换都可以放在一个矩阵中，用这个矩阵乘以我们的向量将变换(Transform)这个向量。</p><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & 0\\ 0 &  1& 0 & 0\\ 0 &  0&  1&0 \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ w\end{bmatrix} = \begin{bmatrix}x\\ y\\ z\\ w\end{bmatrix}</script><blockquote><p>单位矩阵通常是生成其他变换矩阵的起点，如果我们深挖线性代数，这还是一个对证明定理、解线性方程非常有用的矩阵。</p></blockquote><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>假设缩放向量表示为$\left ( S_1, S_2,S_3 \right )$:</p><script type="math/tex; mode=display">\begin{bmatrix}S_1 & 0 & 0 & 0\\ 0 &  S_2& 0 & 0\\ 0 &  0&  S_3&0 \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}S_1 \cdot x\\ S_2 \cdot y\\ S_3 \cdot z\\ 1\end{bmatrix}</script><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><p>假设位移向量表示为$\left ( T_x, T_y,T_z \right )$:</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & T_x\\ 0 &  1& 0 & T_y\\ 0 &  0&  1&T_z \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}x + T_x\\ y + T_y\\ z + T_z\\ 1\end{bmatrix}</script><blockquote><p><strong>齐次坐标(Homogeneous Coordinates)</strong><br>向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。<br>如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。</p></blockquote><p>因为所有的位移值都要乘以向量的w行，所以位移值会加到向量的原始值上（想想矩阵乘法法则）。而如果你用3x3矩阵我们的位移值就没地方放也没地方乘了，所以是不行的。有了位移矩阵我们就可以在3个方向(x、y、z)上移动物体，它是我们的变换工具箱中非常有用的一个变换矩阵。</p><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><blockquote><p>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p><ul><li>弧度转角度：<strong>角度 = 弧度 * (180.0f / PI)</strong></li><li>角度转弧度：<strong>弧度 = 角度 * (PI / 180.0f)</strong></li></ul><p>PI约等于3.14159265359。</p></blockquote><p>在3D空间中旋转需要定义一个角和一个旋转轴(Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。如果你想要更形象化的感受，可以试试向下看着一个特定的旋转轴，同时将你的头部旋转一定角度。当2D向量在3D空间中旋转时，我们把旋转轴设为z轴（尝试想象这种情况）。</p><p>使用三角学，给定一个角度，可以把一个向量变换为一个经过旋转的新向量。这通常是使用一系列正弦和余弦函数（一般简称sin和cos）各种巧妙的组合得到的。</p><p>旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用θ表示：</p><h3 id="沿x轴旋转："><a href="#沿x轴旋转：" class="headerlink" title="沿x轴旋转："></a>沿x轴旋转：</h3><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & 0\\ 0 &  cos\theta& -sin\theta & 0\\ 0 &  sin\theta&  cos\theta&0 \\  0& 0 &0  & 1\end{bmatrix}  \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix}  = \begin{bmatrix}x\\ cos\theta \cdot y - sin\theta \cdot z\\ sin\theta \cdot y + cos\theta \cdot z\\ 1\end{bmatrix}</script><h3 id="沿y轴旋转："><a href="#沿y轴旋转：" class="headerlink" title="沿y轴旋转："></a>沿y轴旋转：</h3><script type="math/tex; mode=display">\begin{bmatrix}cos\theta & 0 & sin\theta& 0\\ 0 &  1& 0 & 0\\ -sin\theta &  0& cos\theta&0 \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}cos\theta \cdot x + sin\theta \cdot z\\ y\\ -sin\theta \cdot x + cos\theta \cdot z\\ 1\end{bmatrix}</script><h3 id="沿z轴旋转："><a href="#沿z轴旋转：" class="headerlink" title="沿z轴旋转："></a>沿z轴旋转：</h3><script type="math/tex; mode=display">\begin{bmatrix}cos\theta & -sin\theta & 0 & 0\\ sin\theta &  cos\theta& 0 & 0\\ 0 &  0& 1&0 \\  0& 0 &0  & 1\end{bmatrix} \cdot \begin{bmatrix}x\\ y\\ z\\ 1\end{bmatrix} = \begin{bmatrix}cos\theta \cdot x - sin\theta \cdot y\\ sin\theta \cdot x + cos\theta \cdot y\\ z\\ 1\end{bmatrix}</script><h3 id="沿任意轴旋转："><a href="#沿任意轴旋转：" class="headerlink" title="沿任意轴旋转："></a>沿任意轴旋转：</h3><p>利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。也可以将多个矩阵复合，比如先沿着x轴旋转再沿着y轴旋转。但是这会很快导致一个问题——<code>万向节死锁</code>。在这里我们不会讨论它的细节，但是对于3D空间中的旋转，一个更好的模型是沿着任意的一个轴，比如单位向量$(0.662, 0.2, 0.7222)$旋转，而不是对一系列旋转矩阵进行复合。这样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中$\left ( R_x, R_y,R_z \right )$代表任意旋转轴：</p><script type="math/tex; mode=display">\begin{bmatrix}cos\theta + {R_x}^2(1-cos\theta)) & R_xR_y(1-cos\theta)-R_zsin\theta  & R_xR_z(1-cos\theta)+R_ysin\theta & 0\\ R_yR_x(1-cos\theta)+R_zsin\theta &  cos\theta + {R_y}^2(1-cos\theta)& R_yR_z(1-cos\theta)-R_xsin\theta & 0\\ R_zR_x(1-cos\theta)-R_ysin\theta &  R_zR_y(1-cos\theta)+R_xsin\theta& cos\theta + {R_z}^2(1-cos\theta)&0 \\  0& 0 &0  & 1\end{bmatrix}</script><p>在数学上讨论如何生成这样的矩阵仍然超出了本节内容。但是记住，即使这样一个矩阵也不能完全解决万向节死锁问题（尽管会极大地避免）。避免万向节死锁的真正解决方案是使用<code>四元数(Quaternion)</code>，它不仅更安全，而且计算会更有效率。四元数可能会在后面的教程中讨论。</p><blockquote><p>对四元数的理解会用到非常多的数学知识。如果你想了解四元数与3D旋转之间的关系，可以来阅读<a href="https://krasjet.github.io/quaternion/">教程</a>。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读<a href="https://krasjet.github.io/quaternion/bonus_gimbal_lock.pdf">这里</a>。</p><p>现在3Blue1Brown也已经开始了一个四元数的视频系列，他采用球极平面投影(Stereographic Projection)的方式将四元数投影到3D空间，同样有助于理解四元数的概念（仍在更新中）：<a href="https://www.youtube.com/watch?v=d4EgbgTm0Bg">https://www.youtube.com/watch?v=d4EgbgTm0Bg</a></p></blockquote><h2 id="矩阵的组合"><a href="#矩阵的组合" class="headerlink" title="矩阵的组合"></a>矩阵的组合</h2><p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该<code>从右向左</code>读这个乘法。建议您在组合矩阵时，<strong>先进行缩放操作，然后是旋转，最后才是位移</strong>，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>现在我们已经解释了变换背后的所有理论，是时候将这些知识利用起来了。OpenGL没有自带任何的矩阵和向量知识，所以我们必须定义自己的数学类和函数。在教程中我们更希望抽象所有的数学细节，使用已经做好了的数学库。幸运的是，有个易于使用，专门为OpenGL量身定做的数学库，那就是GLM。</p><h2 id="GLM"><a href="#GLM" class="headerlink" title="GLM"></a>GLM</h2><p><code>GLM</code>是OpenGL Mathematics的缩写，它是一个只有头文件的库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的<a href="https://glm.g-truc.net/0.9.8/index.html">网站</a>上下载。把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。</p><blockquote><p>GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的矩阵初始化改为 <strong>glm::mat4 mat = glm::mat4(1.0f)</strong>。</p></blockquote><p>我们需要的GLM的大多数功能都可以从下面这3个头文件中找到：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="变换表示"><a href="#变换表示" class="headerlink" title="变换表示"></a>变换表示</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mat4-&gt;4*4矩阵</span></span><br><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);<span class="comment">//如果使用的是0.9.9及以上版本需要自主赋值为单位矩阵</span></span><br><span class="line"><span class="comment">//位移向量（1, 1, 0）</span></span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line"><span class="comment">//沿z轴（0, 0, 1）旋转90度</span></span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line"><span class="comment">//缩放向量（0.5, 0.5, 0.5）</span></span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure><p>因为我们把这个矩阵传递给了GLM的每个函数，GLM会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。<code>实际的变换顺序应该与阅读顺序相反</code>：尽管在代码中我们先位移再旋转，实际的变换却是先应用旋转再是位移的。明白所有这些变换的组合，并且知道它们是如何应用到物体上是一件非常困难的事情。只有不断地尝试和实验这些变换你才能快速地掌握它们。也就是定义trans的时候是从左至右但是实际加到向量上作用是从右向左的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>如何把矩阵传递给着色器？我们在前面简单提到过GLSL里也有一个mat4类型。所以我们将修改顶点着色器让其接收一个mat4的uniform变量，然后再用矩阵uniform乘以位置向量：</p><p>修改顶点着色器代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line">out vec3 ourColor;</span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = transform * vec4(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = vec2(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);<span class="comment">//适应图片y轴相反的另一种方式</span></span><br><span class="line">    ourColor = aColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意到纹理单元是定义在片段着色器的，而矩阵定义在顶点着色器，一个关注的是位置，一个关注的是颜色。<br>片段着色器不需要改变。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">    <span class="comment">//FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);//还可以叠加我们设置的顶点颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个先缩放再向左旋转90度的变换矩阵</span></span><br><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">ourShader.use();<span class="comment">// don&#x27;t forget to activate/use the shader before setting uniforms!</span></span><br><span class="line"><span class="comment">// 把变换矩阵传递给着色器</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> transformLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染循环不用改变</span></span><br><span class="line">[---]</span><br></pre></td></tr></table></figure><p>我们首先查询uniform变量的地址，然后用有Matrix4fv后缀的<code>glUniform</code>函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是uniform的位置值。第二个参数告诉OpenGL我们将要发送多少个矩阵，这里是1。第三个参数询问我们我们是否希望对我们的矩阵进行置换(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序(Column-major Ordering)布局。GLM的默认布局就是列主序，所以并不需要置换矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数value_ptr来变换这些数据。</p><p>以上可以在循环外进行赋值，但是如果要让箱子随着时间推移旋转，我们就必须在游戏循环中更新变换矩阵，因为它在每一次渲染迭代中都要更新。</p><p>包含了练习题答案的打包，可以看到改变位移和旋转顺序以后是有区别的。本质是矩阵运算的原因。先旋转后位移就是在位移后原地转，先位移再旋转会绕原点转。此处的先后是真实的矩阵变换顺序也就是逆定义的顺序。</p><p>结果如下，后面有代码，加上之前的顶点着色器即可，片段着色器不需要改变。</p><video width="480" height="320" controls><source src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.5/tran.mp4"></video><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// build and compile our shader zprogram</span></span><br><span class="line">    <span class="comment">// ------------------------------------</span></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;./shader/vertex_matrix.txt&quot;</span>, <span class="string">&quot;./shader/fragment_texture_try_1.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">        <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// first triangle</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// second triangle</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO, EBO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// color attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// texture coord attribute</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    <span class="comment">//stbi_set_flip_vertically_on_load(true); // tell stb_image.h to flip loaded texture&#x27;s on the y-axis.</span></span><br><span class="line">                                            <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = stbi_load(<span class="string">&quot;awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell opengl for each sampler to which texture unit it belongs to (only has to be done once)</span></span><br><span class="line">    <span class="comment">// -------------------------------------------------------------------------------------------</span></span><br><span class="line">    ourShader.use(); <span class="comment">// don&#x27;t forget to activate/use the shader before setting uniforms!</span></span><br><span class="line">                     <span class="comment">// either set it manually like so:</span></span><br><span class="line">    glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// or set it via the texture class</span></span><br><span class="line">    ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先缩小再旋转再位移到右上角</span></span><br><span class="line">    glm::mat4 trans_static = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    trans_static = glm::translate(trans_static, glm::vec3(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    trans_static = glm::rotate(trans_static, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    trans_static = glm::scale(trans_static,  glm::vec3(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">        glActiveTexture(GL_TEXTURE0);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">        glActiveTexture(GL_TEXTURE1);</span><br><span class="line">        glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render container</span></span><br><span class="line">        ourShader.use();</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> transformLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line">        glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans_static));</span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">        trans = glm::rotate(trans, (<span class="keyword">float</span>)glfwGetTime(), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">        trans = glm::translate(trans, glm::vec3(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans));</span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">        trans = glm::translate(trans, glm::vec3(<span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        trans = glm::scale(trans, glm::vec3(<span class="built_in">sin</span>((<span class="keyword">float</span>)glfwGetTime()), <span class="built_in">sin</span>((<span class="keyword">float</span>)glfwGetTime()), <span class="built_in">sin</span>((<span class="keyword">float</span>)glfwGetTime())));</span><br><span class="line">        glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans));</span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记1.4-纹理</title>
    <link href="https://idinghy.com/2020/12/01/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-4-%E7%BA%B9%E7%90%86/"/>
    <id>https://idinghy.com/2020/12/01/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-4-%E7%BA%B9%E7%90%86/</id>
    <published>2020-12-01T09:22:33.000Z</published>
    <updated>2020-12-02T01:40:55.051Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>官方课程主页见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/#_7">这里</a></li><li>官方代码（笑脸+箱子）见<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/4.2.textures_combined/textures_combined.cpp">这里</a></li><li>图片<ul><li>砖墙图片见<a href="https://learnopengl-cn.github.io/img/01/06/wall.jpg">这里</a></li><li>木箱图片见<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg">这里</a></li><li>笑脸图片见<a href="https://img2018.cnblogs.com/blog/1536438/201907/1536438-20190727142926543-204923522.png">这里</a></li></ul></li></ul><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/1.png)</center><ul><li>一个自学博主的笔记<a href="https://www.cnblogs.com/zhxmdefj/category/1502112.html">参考</a><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1></li></ul><p>我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。</p><p>艺术家和程序员更喜欢使用<code>纹理(Texture)</code>。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><p>比如为三角形赋三个顶点和颜色自动插值后的结果会是：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/2.png)</center>使用纹理后可以在定义三个顶点的基础上从图片中`采样`,得到的结果会是（图中标的是纹理坐标）：<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/3.png)</center><p>接下来我们来看是如何实现的。</p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>概括来说，本章内容大致是加载纹理图片，创建纹理对象，进行一些配置，包括纹理坐标，纹理环绕方式，纹理过滤，多级渐远纹理等。最后我们如何使用纹理，着色器如何进行代码的适配。</p><p>本文的例子是一个2D纹理，贴在我们定义好的矩形上。</p><p>在这里我们需要get几个词的意思。</p><h2 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h2><p>为了能够把纹理映射(Map)到我们定义的图形上，我们需要指定图形每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个<code>纹理坐标(Texture Coordinate)</code>，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p><p>纹理坐标在x和y轴上，<code>范围为0到1之间</code>（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。</p><p>举例说明，我们定义四个顶点用GL_TRIANGLE提示图元拼成一个矩形。</p><p>如果我们要让图片占满，如图：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/4.png)</center>那么定义的位置和纹理坐标应该是：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// positions                 // texture coords</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="comment">// top right</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom right</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom left</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>  <span class="comment">// top left </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>占左下角的话，如图<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/5.png)</center>纹理坐标要变成：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="comment">// top right</span></span><br><span class="line">    <span class="number">2.0f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom right</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// bottom left</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">2.0f</span>  <span class="comment">// top left </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在中间的话，如图<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/6.png)</center>纹理坐标要变成：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">1.5f</span>, <span class="number">1.5f</span>, <span class="comment">// top right</span></span><br><span class="line">    <span class="number">1.5f</span>, <span class="number">-0.5f</span>, <span class="comment">// bottom right</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="comment">// bottom left</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">1.5f</span>  <span class="comment">// top left </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>纹理坐标大概就是这么对应的，但是我们可以看到以上有的时候我们把纹理坐标设置在范围之外了，那那些区域的值是如何定义的呢，你可以看到上面范围之外的都是黑色，那其实是为了更加明显的显示出纹理坐标我设置成了黑色，OpenGL提供了更多的选择关于如何处置这部分的结果。## 纹理环绕方式纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：|环绕方式|描述||:---|:---||GL_REPEAT    |对纹理的默认行为。重复纹理图像。||GL_MIRRORED_REPEAT    |和GL_REPEAT一样，但每次重复图片是镜像放置的。||GL_CLAMP_TO_EDGE    |纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。||GL_CLAMP_TO_BORDER|    超出的坐标为用户指定的边缘颜色。|当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/7.png)</center><p>前面提到的每个选项都可以使用glTexParameter函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><br>第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是<code>WRAP</code>选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</p><p>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><br>破案了，上面我们正是设置了s轴和t轴的环绕方式为GL_CLAMP_TO_BORDER，然后传递一个黑色的rgb值作为边缘的颜色值产生了纹理坐标讲解部分的效果。</p><h2 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。理解一下下面的话，比较重要。</p><blockquote><p>Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。</p></blockquote><p><code>GL_NEAREST</code>（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/8.png)</center><p><code>GL_LINEAR</code>（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/9.png)</center><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/10.png" alt="description"></p><p>&lt;/center&gt;<br>GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p><p>当进行<code>放大(Magnify)</code>和<code>缩小(Minify)</code>操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用<code>glTexParameter</code>函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure></p><h2 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h2><p>想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p><p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/11.png" alt="description"></p><p>&lt;/center&gt;<br>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。</p><p>在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p><div class="table-container"><table><thead><tr><th style="text-align:left">过滤方式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_NEAREST_MIPMAP_NEAREST</td><td style="text-align:left">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td style="text-align:left">GL_LINEAR_MIPMAP_NEAREST</td><td style="text-align:left">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td style="text-align:left">GL_NEAREST_MIPMAP_LINEAR</td><td style="text-align:left">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td style="text-align:left">GL_LINEAR_MIPMAP_LINEAR</td><td style="text-align:left">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table></div><p>就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><br>一个<code>常见的错误</code>是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为<strong>多级渐远纹理主要是使用在纹理被缩小的情况下的</strong>：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p><h1 id="加载和创建纹理"><a href="#加载和创建纹理" class="headerlink" title="加载和创建纹理"></a>加载和创建纹理</h1><h2 id="加载图像"><a href="#加载图像" class="headerlink" title="加载图像"></a>加载图像</h2><p>使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。</p><p>另一个解决方案也许是一种更好的选择，使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如说我们要用的<code>stb_image.h</code>库。</p><p>stb_image.h是Sean Barrett的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。stb_image.h可以在<a href="https://github.com/nothings/stb/blob/master/stb_image.h">这里</a>下载。下载这一个头文件，将它以stb_image.h的名字加入你的工程，并另创建一个新的C++文件，输入以下代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure><br>通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含stb_image.h并编译就可以了。</p><p>首先我们需要一张<a href="https://learnopengl-cn.github.io/img/01/06/container.jpg">木箱</a>的图片，要使用stb_image.h加载图片，我们需要使用它的stbi_load函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><br><code>stbi_load</code>首先接受一个图像文件的位置作为输入。接下来它需要三个int作为它的第二、第三和第四个参数，stb_image.h将会用图像的宽度、高度和颜色通道的个数填充这三个变量。我们之后生成纹理的时候会用到的图像的宽度和高度的。</p><h2 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h2><p>和之前生成的OpenGL对象一样，纹理也是使用ID引用的。让我们来创建一个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><br>glGenTextures函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的unsigned int数组中（我们的例子中只是单独的一个unsigned int），就像其他对象一样，我们需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理。<br>现在纹理已经绑定了，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过glTexImage2D来生成：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure><br><code>glTexImage2D</code>函数很长，参数也不少，所以我们一个一个地讲解：</p><ul><li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li><li>第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。</li><li>第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。</li><li>第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。</li><li>下个参数应该总是被设为0（历史遗留的问题）。</li><li>第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。</li><li>最后一个参数是真正的图像数据。<br>当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要<code>使用多级渐远纹理</code>，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</li></ul><p>生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure><p>生成一个纹理的过程应该看起来像这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (data)</span><br><span class="line">&#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure></p><h2 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h2><p>以上我们就加载好纹理了,以下代码基于<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp">这里</a>。具体应用的时候我们需要告知OpenGL如何采样纹理，即纹理坐标的设定以及着色器如何获取数据。</p><p>首先使用纹理坐标更新顶点数据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.4/12.png" alt="description"></p><p>&lt;/center&gt;<br>相应代码部分变为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set up vertex data (and buffer(s)) and configure vertex attributes</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">    <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// first triangle</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// second triangle</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO, EBO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// position attribute</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// color attribute</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// texture coord attribute</span></span><br><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>接着我们需要调整<code>顶点着色器</code>使其能够<strong>接受顶点坐标为一个顶点属性，并把坐标传给片段着色器</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor;</span><br><span class="line">layout (location = <span class="number">2</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec3 ourColor;</span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>片段着色器</code>应该接下来会把输出变量<strong>TexCoord</strong>作为输入变量。<br><strong>片段着色器也应该能访问纹理对象</strong>，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做<code>采样器(Sampler)</code>，它以纹理类型作为后缀，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p><p>基础版代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 片段着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = texture(ourTexture, TexCoord);</span><br><span class="line">    <span class="comment">//FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0);//还可以叠加我们设置的顶点颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染循环中</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>你可能会奇怪为什么sampler2D变量是个uniform，我们却不用glUniform给它赋值。<strong>使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理</strong>。</p><blockquote><p>一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。</p></blockquote><h2 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h2><p>纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><br>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</p><blockquote><p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。<br>代码会变为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *******************************************</span></span><br><span class="line"><span class="comment">// 片段着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line">uniform sampler2D texture2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *******************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  主程序中载入并创建两个纹理</span></span><br><span class="line"><span class="comment">// load and create a texture </span></span><br><span class="line">    <span class="comment">// -------------------------</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> texture1, texture2;</span><br><span class="line">    <span class="comment">// texture 1</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture1);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    <span class="keyword">float</span> borderColor[] = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    <span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line">    stbi_set_flip_vertically_on_load(<span class="literal">true</span>); <span class="comment">// tell stb_image.h to flip loaded texture&#x27;s on the y-axis.OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。很幸运，stb_image.h能够在图像加载时帮助我们翻转y轴，只需要在加载任何图像前加入以下语句即可：</span></span><br><span class="line">                                            <span class="comment">// The FileSystem::getPath(...) is part of the GitHub repository so we can find files on any IDE/platform; replace it with your own image path.</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line">    <span class="comment">// texture 2</span></span><br><span class="line">    <span class="comment">// ---------</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture2);</span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line">    <span class="comment">// set the texture wrapping parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);    <span class="comment">// set texture wrapping to GL_REPEAT (default wrapping method)</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);</span><br><span class="line">    <span class="comment">// set texture filtering parameters</span></span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="comment">// load image, create texture and generate mipmaps</span></span><br><span class="line">    data = stbi_load(<span class="string">&quot;awesomeface.png&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// note that the awesomeface.png has transparency and thus an alpha channel, so make sure to tell OpenGL the data type is of GL_RGBA</span></span><br><span class="line">        glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA, width, height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br><span class="line">        glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stbi_image_free(data);</span><br><span class="line"><span class="comment">// 使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元, 只有一个的时候不需要，默认会绑定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ourShader.use(); <span class="comment">// 不要忘记在设置uniform变量之前激活着色器程序！</span></span><br><span class="line">glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>); <span class="comment">// 手动设置</span></span><br><span class="line">ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>); <span class="comment">// 或者使用着色器类设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************************************</span></span><br><span class="line"><span class="comment">//渲染循环中：</span></span><br><span class="line"><span class="comment">// bind textures on corresponding texture units</span></span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// render container</span></span><br><span class="line">ourShader.use();</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记1.3-着色器</title>
    <link href="https://idinghy.com/2020/11/30/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-3-%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    <id>https://idinghy.com/2020/11/30/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-3-%E7%9D%80%E8%89%B2%E5%99%A8/</id>
    <published>2020-11-30T13:46:59.000Z</published>
    <updated>2020-11-30T13:53:07.657Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>官方课程主页见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/">这里</a></li><li>官方着色器类见<a href="https://learnopengl.com/code_viewer_gh.php?code=includes/learnopengl/shader_s.h">这里</a></li></ul><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>在<a href="https://idinghy.com/2020/11/30/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.2-%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%89%E8%A7%92%E5%BD%A2/">上一节</a>教程中提到，<code>着色器(Shader)</code>是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。<strong>从基本意义上来说，着色器只是一种把输入转化为输出的程序。</strong>着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p><p>前面的教程里我们简要地触及了一点着色器的皮毛，并了解了如何恰当地使用它们。现在我们会用一种更加广泛的形式详细解释着色器，特别是OpenGL着色器语言(GLSL)。</p><h1 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h1><p>着色器是使用一种叫<code>GLSL</code>的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p><p>着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。</p><p>一个典型的着色器有下面的结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line">in type in_variable_name;</span><br><span class="line">in type in_variable_name;</span><br><span class="line"></span><br><span class="line">out type out_variable_name;</span><br><span class="line"></span><br><span class="line">uniform type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们特别谈论到顶点着色器的时候，每个输入变量也叫<code>顶点属性(Vertex Attribute)</code>。由location标识。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询<em>GL_MAX_VERTEX_ATTRIBS</em>来获取具体的上限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nrAttributes;</span><br><span class="line">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum nr of vertex attributes supported: &quot;</span> &lt;&lt; nrAttributes &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="单变量"><a href="#单变量" class="headerlink" title="单变量"></a>单变量</h2><p>和其他编程语言一样，GLSL有数据类型可以来指定变量的种类。GLSL中包含C等其它语言大部分的默认基础数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>uint</code>和<code>bool</code>。GLSL也有两种容器类型，它们会在这个教程中使用很多，分别是向量(Vector)和矩阵(Matrix)，其中矩阵我们会在之后的教程里再讨论。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">vecn</td><td style="text-align:left">包含n个float分量的默认向量</td></tr><tr><td style="text-align:left">bvecn</td><td style="text-align:left">包含n个bool分量的向量</td></tr><tr><td style="text-align:left">ivecn</td><td style="text-align:left">包含n个int分量的向量</td></tr><tr><td style="text-align:left">uvecn</td><td style="text-align:left">包含n个unsigned int分量的向量</td></tr><tr><td style="text-align:left">dvecn</td><td style="text-align:left">包含n个double分量的向量</td></tr></tbody></table></div><p>一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用<code>.x</code>、<code>.y</code>、<code>.z</code>和<code>.w</code>来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用<code>rgba</code>，或是对纹理坐标使用<code>stpq</code>访问相同的分<br>量。</p><p>向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vec2 someVec;</span><br><span class="line">vec4 differentVec = someVec.xyxx;</span><br><span class="line">vec3 anotherVec = differentVec.zyw;</span><br><span class="line">vec4 otherVec = someVec.xxxx + anotherVec.yxzy;</span><br><span class="line">vec2 vect = vec2(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line">vec4 result = vec4(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec4 otherResult = vec4(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h1 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h1><p>虽然着色器是各自独立的小程序，但是它们都是一个整体的一部分，出于这样的原因，我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，<strong>只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去</strong>。但在顶点和片段着色器中会有点不同。</p><p><code>顶点着色器</code>应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的<code>layout</code>标识，这样我们才能把它链接到顶点数据。</p><p>另一个例外是<code>片段着色器</code>，它需要一个<code>vec4</code>颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。</p><p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须<strong>在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入</strong>。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。</p><p>例如以下实现在顶点着色器中将片段颜色设置为深红色。</p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line">out vec4 vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = vec4(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec4 vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是in 和 out的使用，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。</p><p>其中顶点着色器中<code>in</code>的顶点属性一般根据vertice-VBO-VAO-EBO这些从中获取， out一般是为了传递数据，在main中赋值，片段着色器可以接收前面的out作为in，并且一定会要输出vec4的颜色。</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>这样传递的话很明显对所有点画的颜色是一样的，除非定制不同的着色器程序，或者用下面即将学到的uniform，画一个顶点配置一个，过于繁琐。所以我们可以给点除了加位置属性还加上颜色属性。</p><p>在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器源码</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;   <span class="comment">// 位置变量的属性位置值为 0 </span></span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line">out vec3 ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 片段着色器源码</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;  </span><br><span class="line">in vec3 ourColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vec4(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码中</span></span><br><span class="line"><span class="comment">// 顶点的定义</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染循环中</span></span><br><span class="line"><span class="comment">// render the triangle</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.3/1.png)</center><p>把数据写入缓存以后，内存的布局如上，所以我们相应改动了不同location的内存解释，即可为每个顶点配置颜色。</p><p><code>glVertexAttribPointer</code>函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。</p><p>由于我们现在有了两个顶点属性，我们不得不重新计算步长值。为获得数据队列中下一个属性值（比如位置向量的下个x分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为6乘以float的字节数（=24字节）。<br>同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是3 * sizeof(float)，用字节来计算就是12字节。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.3/2.png)</center><p>这个图片可能不是你所期望的那种，因为我们只提供了3个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓片段<code>插值(Fragment Interpolation)</code>的结果。当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置。<br>基于这些位置，它会插值(Interpolate)所有片段着色器的输入变量。比如说，我们有一个线段，上面的端点是绿色的，下面的端点是蓝色的。如果一个片段着色器在线段的70%的位置运行，它的颜色输入属性就会是一个绿色和蓝色的线性结合；更精确地说就是30%蓝 + 70%绿。</p><p>这正是在这个三角形中发生了什么。我们有3个顶点，和相应的3个颜色，从这个三角形的像素来看它可能包含50000左右的片段，片段着色器为这些像素进行插值颜色。如果你仔细看这些颜色就应该能明白了：红首先变成到紫再变为蓝色。片段插值会被应用到片段着色器的所有输入属性上。</p><h1 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h1><p><code>Uniform</code>是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着<strong>uniform变量必须在每个着色器程序对象中都是独一无二的</strong>，而且它<strong>可以被着色器程序的任意着色器在任意阶段访问</strong>。第二，无论你把uniform值设置成什么，uniform会<strong>一直保存它们的数据，直到它们被重置或更新</strong>。</p><p>uniform不需要前后链接的着色器都定义。哪里需要哪里定义即可。</p><blockquote><p>如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</p></blockquote><p>使用的时候我们首先需要找到着色器中uniform属性的索引/位置值。当我们得到uniform的索引/位置值后，我们就可以更新它的值了。相当于我们可以在程序中动态的传入数据改变着色器。记得使用前要激活着色器。</p><p>比如我们令片段着色器接收uniform的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">uniform vec4 ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后渲染循环中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    processInput(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染</span></span><br><span class="line">    <span class="comment">// 清除颜色缓冲</span></span><br><span class="line">    glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得激活着色器</span></span><br><span class="line">    glUseProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新uniform颜色</span></span><br><span class="line">    <span class="keyword">float</span> timeValue = glfwGetTime();</span><br><span class="line">    <span class="keyword">float</span> greenValue = <span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span> + <span class="number">0.5f</span>;</span><br><span class="line">    <span class="keyword">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">    glUniform4f(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制三角形</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲并查询IO事件</span></span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">    glfwPollEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中因为OpenGL在其核心是一个C库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；<code>glUniform</code>是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有：</p><div class="table-container"><table><thead><tr><th style="text-align:left">后缀</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">f</td><td style="text-align:left">函数需要一个float作为它的值</td></tr><tr><td style="text-align:left">i</td><td style="text-align:left">函数需要一个int作为它的值</td></tr><tr><td style="text-align:left">ui</td><td style="text-align:left">函数需要一个unsigned int作为它的值</td></tr><tr><td style="text-align:left">3f</td><td style="text-align:left">函数需要3个float作为它的值</td></tr><tr><td style="text-align:left">fv</td><td style="text-align:left">函数需要一个float向量/数组作为它的值</td></tr></tbody></table></div><p>每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定uniform的4个float值，所以我们通过glUniform4f传递我们的数据(注意，我们也可以使用fv版本)。</p><p>每次迭代绘制三角形前先更新uniform值。如果你正确更新了uniform，你会看到你的三角形逐渐由绿变黑再变回绿色。可以看到，uniform对于设置一个在渲染迭代中会改变的属性是一个非常有用的工具，它也是一个在程序和着色器间数据交互的很好工具。</p><h1 id="着色器类来了"><a href="#着色器类来了" class="headerlink" title="着色器类来了"></a>着色器类来了</h1><p>之前写着色器的时候可以发现除了源码变动，创造一个着色器程序基本就是重复劳动，我们可以写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测。这样我们只用关注着色器的源码部分和后面程序逻辑。<br>头文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shader.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 程序ID</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">    Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath);</span><br><span class="line">    <span class="comment">// 使用/激活程序</span></span><br><span class="line">    ~Shader() &#123;</span><br><span class="line">        glDeleteProgram(ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// uniform工具函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// utility function for checking shader compilation/linking errors.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkCompileErrors</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> shader, <span class="built_in">std</span>::<span class="built_in">string</span> type)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>源文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shader.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor generates the shader on the fly</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">Shader::Shader(<span class="keyword">const</span> <span class="keyword">char</span>* vertexPath, <span class="keyword">const</span> <span class="keyword">char</span>* fragmentPath) &#123;</span><br><span class="line">    <span class="comment">// 1. retrieve the vertex/fragment source code from filePath</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> vertexCode;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fragmentCode;</span><br><span class="line">    <span class="built_in">std</span>::ifstream vShaderFile;</span><br><span class="line">    <span class="built_in">std</span>::ifstream fShaderFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure ifstream objects can throw exceptions:</span></span><br><span class="line">    vShaderFile.exceptions(<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line">    fShaderFile.exceptions(<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// open files</span></span><br><span class="line">        vShaderFile.open(vertexPath);</span><br><span class="line">        fShaderFile.open(fragmentPath);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> vShaderStream, fShaderStream;</span><br><span class="line">        <span class="comment">// read file&#x27;s buffer contents into streams</span></span><br><span class="line">        vShaderStream &lt;&lt; vShaderFile.rdbuf();</span><br><span class="line">        fShaderStream &lt;&lt; fShaderFile.rdbuf();</span><br><span class="line">        <span class="comment">// close file handlers</span></span><br><span class="line">        vShaderFile.close();</span><br><span class="line">        fShaderFile.close();</span><br><span class="line">        <span class="comment">// convert stream into string</span></span><br><span class="line">        vertexCode = vShaderStream.str();</span><br><span class="line">        fragmentCode = fShaderStream.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::ifstream::failure e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vShaderCode = vertexCode.c_str();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fShaderCode = fragmentCode.c_str();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. compile shaders</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertex, fragment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vertex shader</span></span><br><span class="line">    vertex = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertex, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertex);</span><br><span class="line">    checkCompileErrors(vertex, <span class="string">&quot;VERTEX&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fragment Shader</span></span><br><span class="line">    fragment = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragment, <span class="number">1</span>, &amp;fShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragment);</span><br><span class="line">    checkCompileErrors(fragment, <span class="string">&quot;FRAGMENT&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shader Program</span></span><br><span class="line">    ID = glCreateProgram();</span><br><span class="line">    glAttachShader(ID, vertex);</span><br><span class="line">    glAttachShader(ID, fragment);</span><br><span class="line">    glLinkProgram(ID);</span><br><span class="line">    checkCompileErrors(ID, <span class="string">&quot;PROGRAM&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the shaders as they&#x27;re linked into our program now and no longer necessary</span></span><br><span class="line">    glDeleteShader(vertex);</span><br><span class="line">    glDeleteShader(fragment);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// activate the shader</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glUseProgram(ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// utility uniform functions</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::setBool</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), (<span class="keyword">int</span>)value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::setInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::setFloat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1f(glGetUniformLocation(ID, name.c_str()), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// utility function for checking shader compilation/linking errors.</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shader::checkCompileErrors</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> shader, <span class="built_in">std</span>::<span class="built_in">string</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">if</span> (type != <span class="string">&quot;PROGRAM&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            glGetShaderInfoLog(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER_COMPILATION_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        glGetProgramiv(shader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            glGetProgramInfoLog(shader, <span class="number">1024</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::PROGRAM_LINKING_ERROR of type: &quot;</span> &lt;&lt; type &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="string">&quot;\n -- --------------------------------------------------- -- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;path/to/shaders/shader.vs&quot;</span>, <span class="string">&quot;path/to/shaders/shader.fs&quot;</span>)</span></span>;<span class="comment">//这两个文件写着色器的源码</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">    ourShader.use();</span><br><span class="line">    ourShader.setFloat(<span class="string">&quot;someUniform&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    DrawStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="练习题打包解答"><a href="#练习题打包解答" class="headerlink" title="练习题打包解答"></a>练习题打包解答</h1><p>vertex_try_123.txt<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line">layout (location = <span class="number">1</span>) in vec3 aColor; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line">out vec4 ourColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> xoffset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x + xoffset, -aPos.y, aPos.z, <span class="number">1.0</span>); <span class="comment">// 注意我们如何把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    ourColor = vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>fragment_try_123.txt<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">in vec4 ourColor;</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>main.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化GLFW</span></span><br><span class="line">    glfwInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用glfwWindowHint函数来配置GLFW(https://www.glfw.org/docs/latest/window.html#window_hints)</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//设置主版本号为3</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//设置次版本号为3</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//告诉GLFW我们使用的是核心模式(Core - profile)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);<span class="comment">//如果使用的是Mac OS X系统需要加上此行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个窗口对象</span></span><br><span class="line">    <span class="comment">//glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题）,最后两个参数我们暂时忽略。返回一个GLFWwindow对象。</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建失败处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通知GLFW将我们窗口的上下文设置为当前线程的主上下文。</span></span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    <span class="comment">//告诉GLFW我们希望每当窗口调整大小的时候调用</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line">    <span class="comment">//我们给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;./shader/vertex_try_12.txt&quot;</span>, <span class="string">&quot;./shader/fragment_try_12.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="comment">// 位置              // 颜色</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,    <span class="comment">// 顶部</span></span><br><span class="line">        - <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,    <span class="comment">// 顶部</span></span><br><span class="line">        <span class="number">0.5f</span>,  <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 位置属性</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 颜色属性</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop:它能在我们让GLFW退出前一直保持运行</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);<span class="comment">//检测特定的键是否被按下，并在每一帧做出处理。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">//使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);<span class="comment">//清空颜色缓冲</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记得激活着色器</span></span><br><span class="line">        ourShader.use();</span><br><span class="line">        ourShader.setFloat(<span class="string">&quot;xoffset&quot;</span>, <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制三角形</span></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// 交换缓冲并查询IO事件</span></span><br><span class="line">        glfwSwapBuffers(window);<span class="comment">//交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwPollEvents();<span class="comment">//检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>结果：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.3/3.png)</center><p>左下角黑色（因为我还搞了上下颠倒所以现在是左上角黑色），是因为位置是复数的，颜色是复数的时候就会设为0,就是黑色了。</p>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记1.2-你好，三角形</title>
    <link href="https://idinghy.com/2020/11/30/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.2-%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <id>https://idinghy.com/2020/11/30/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.2-%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%89%E8%A7%92%E5%BD%A2/</id>
    <published>2020-11-29T16:13:50.000Z</published>
    <updated>2020-11-29T16:41:03.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>官方课程主页见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/">这里</a></li><li>官方代码版本—使用索引缓冲见<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp">这里</a>。</li><li>官方代码版本—多着色器程序见<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.5.hello_triangle_exercise3/hello_triangle_exercise3.cpp">这里</a>。</li></ul><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。</p><p>3D坐标转为2D坐标的处理过程是由OpenGL的<code>图形渲染管线</code>（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p><p>图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。<strong>这个教程里，我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素。</strong></p><blockquote><p>2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。</p></blockquote><p>图形渲染管线接受一组<strong>3D坐标</strong>，然后把它们转变为你屏幕上的<strong>有色2D像素</strong>输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做<code>着色器(Shader)</code>。</p><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, <code>GLSL</code>)写成的，在下一节中我们再花更多时间研究它。</p><p>下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.2/1.png)</center><ul><li><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做<code>顶点数据(Vertex Data)</code>；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用<strong>顶点属性(Vertex Attribute)</strong>表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置(译注1)和一些颜色值组成的吧。</p></li><li><p>图形渲染管线的第一个部分是<code>顶点着色器(Vertex Shader)</code>，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p></li><li><p><code>图元装配(Primitive Assembly)</code>阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。</p></li><li><p>图元装配阶段的输出会传递给<code>几何着色器(Geometry Shader)</code>。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p></li><li><p>几何着色器的输出会被传入<code>光栅化阶段(Rasterization Stage)</code>，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p></li><li><p><code>片段着色器(Fragment Shader)</code>的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p></li><li><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查<code>alpha</code>值（alpha值定义了一个物体的透明度）并对物体进行<code>混合(Blend)</code>。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p></li></ul><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。</p><blockquote><p>在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p></blockquote><p>接下来我们简单定义一个着色器程序，输入几个点绘制简单的二维图形。代码基于前一节定义的窗口展开。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="着色器部分"><a href="#着色器部分" class="headerlink" title="着色器部分"></a>着色器部分</h2><p>简单来说就是先编写着色器的源码，编译，然后在着色器程序中链接，最后使用。从最简单的开始，我们需要一个顶点着色器和一个片段着色器。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是由着色器语言GLSL(OpenGL Shading Language)编写的一个非常基础的GLSL顶点着色器的源代码。可以看到，GLSL看起来很像C语言。每个着色器都起始于一个<strong>版本声明</strong>。OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用<strong>核心模式</strong>。</p><p>下一步，使用<strong>in关键字</strong>，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL有一个向量数据类型，它包含1到4个float分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个3D坐标，我们就创建一个<strong>vec3</strong>输入变量aPos。我们同样也通过layout (location = 0)设定了输入变量的位置值(Location)。</p><p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是<strong>标准化设备坐标</strong>，所以我们首先必须先把它们转换至OpenGL的可视区域内。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//创建着色器，顶点着色器的着色器类型-GL_VERTEX_SHADER</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将着色器源码附加到着色器对象上，并编译</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">glShaderSource函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为NULL。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测编译时错误并打印</span></span><br><span class="line"><span class="keyword">int</span>  success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色。</p><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);<span class="comment">//RGBA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用out关键字声明输出变量，这里我们命名为FragColor。下面，我们将一个alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"><span class="comment">//创建着色器，片段着色器的着色器类型-GL_FRAGMENT_SHADER</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="comment">//将着色器源码附加到着色器对象上，并编译</span></span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测编译时错误并打印</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p><code>着色器程序对象(Shader Program Object)</code>是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p><h3 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个程序</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们</span></span><br><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测链接着色器程序是否失败</span></span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链接到程序对象以后，记得删除着色器对象</span></span><br><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>这样我们就可以得到一个程序对象<em>shaderProgram</em>，你可以重复以上的步骤定义多个程序对象，然后在渲染循环中用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure><br>调用不同对象，之后每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。</p><p>搞定着色器之后，我们还需要搞定输入顶点数据如何输入内存和解释，如何对接我们的着色器程序。</p><h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>为了简单，我们令这一节绘制的节点的z为0，看平面效果。首先要理解一下这张图。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.2/2.png)</center><p>其中缩写代表的意思分别是：</p><ul><li>顶点数组对象：Vertex Array Object，<strong>VAO</strong></li><li>顶点缓冲对象：Vertex Buffer Object，<strong>VBO</strong></li><li>索引缓冲对象：Element Buffer Object，<strong>EBO</strong>或Index Buffer Object，IBO</li></ul><p>简单来说，一开始我们是有一些顶点，我们需要通过<code>顶点缓冲对象(Vertex Buffer Objects, VBO)</code>管理这个内存。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。</p><p>我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。在GPU上创建内存用于储存我们的顶点数据后，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。</p><p>完整过程是我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。</p><p>每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。所以想到把所有这些状态配置储存在一个对象中，通过绑定这个对象来恢复状态。</p><p><code>顶点数组对象(Vertex Array Object, VAO)</code>可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中。</p><blockquote><p>OpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</p></blockquote><p>要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。</p><p>但是当我们绘制的时候有顶点叠加了，使用上述办法就会产生额外开销。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。</p><p><code>索引缓冲对象</code>(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。</p><p>好的，有了以上认知以后我们来看代码如何写。</p><h3 id="顶点矩阵"><a href="#顶点矩阵" class="headerlink" title="顶点矩阵"></a>顶点矩阵</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有重复</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无重复--使用索引</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="VBO"><a href="#VBO" class="headerlink" title="VBO"></a>VBO</h3><p>实际上跑不起来，因为核心模式下要求我们使用VAO。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每当我们绘制一个物体的时候都必须重复这一过程（在渲染循环中）</span></span><br><span class="line"><span class="comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);<span class="comment">//顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER，从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)</span></span><br><span class="line"></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="comment">//把之前定义的顶点数据复制到缓冲的内存中</span></span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);<span class="comment">// 以顶点属性位置值作为参数，启用顶点属性</span></span><br><span class="line"><span class="comment">// 2. 当我们渲染一个物体时要使用着色器程序</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">// 3. 绘制物体</span></span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure><p>其中<code>glBufferData</code>是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p><p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p><ul><li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li><li>GL_DYNAMIC_DRAW：数据会被改变很多。</li><li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li></ul><p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。</p><p><code>glVertexAttribPointer</code>函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）。</p><ul><li>第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。</li><li>第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。</li><li>第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。</li><li>下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。</li><li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。</li><li>最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li></ul><blockquote><p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。</p></blockquote><p>顶点属性位置值出现在三个地方：</p><ul><li>顶点着色器中 location = 0</li><li>glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 <em> sizeof(float), (void</em>)0);第一个参数</li><li>glEnableVertexAttribArray(0);// 以顶点属性位置值作为参数，启用顶点属性</li></ul><p>我们的顶点缓冲数据会被解析为下面这样子（glVertexAttribPointer函数）：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.2/3.png)</center><ul><li>位置数据被储存为32位（4字节）浮点值。</li><li>每个位置包含3个这样的值。</li><li>在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。</li><li>数据中第一个值在缓冲开始的位置。</li></ul><h3 id="VAO"><a href="#VAO" class="headerlink" title="VAO"></a>VAO</h3><p>复习一下，<code>顶点数组对象(Vertex Array Object, VAO)</code>可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中。</p><p>使用VAO的代码大概是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO, VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// note that this is allowed, the call to glVertexAttribPointer registered VBO as the vertex attribute&#x27;s bound vertex buffer object so afterwards we can safely unbind</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// You can unbind the VAO afterwards so other VAO calls won&#x27;t accidentally modify this VAO, but this rarely happens. Modifying other</span></span><br><span class="line"><span class="comment">// VAOs requires a call to glBindVertexArray anyways so we generally don&#x27;t unbind VAOs (nor VBOs) when it&#x27;s not directly necessary.</span></span><br><span class="line">glBindVertexArray(<span class="number">0</span>); </span><br><span class="line">    </span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br><span class="line"><span class="comment">// glBindVertexArray(0); // no need to unbind it every time </span></span><br></pre></td></tr></table></figure></p><p>一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p><p>主要其实就是两句：</p><ul><li>通过glBindVertexArray(VAO)设置顶点属性配置。</li><li>通过glBindVertexArray(VAO)调用与顶点属性关联的顶点缓冲对象。</li></ul><h3 id="EBO"><a href="#EBO" class="headerlink" title="EBO"></a>EBO</h3><p>复习一下，<code>EBO</code>也是一个缓冲，它专门储存索引，使得我们可以只储存不同的顶点，并设定绘制这些顶点的顺序。OpenGL调用这些顶点的索引来决定该绘制哪个顶点。</p><p>使用方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无重复--使用索引</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓冲对象</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO, VAO, VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p><blockquote><p>目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了</p></blockquote><h3 id="绘制函数"><a href="#绘制函数" class="headerlink" title="绘制函数"></a>绘制函数</h3><h4 id="glDrawArrays-GL-TRIANGLES-0-3"><a href="#glDrawArrays-GL-TRIANGLES-0-3" class="headerlink" title="glDrawArrays(GL_TRIANGLES, 0, 3);"></a>glDrawArrays(GL_TRIANGLES, 0, 3);</h4><p><code>glDrawArrays</code>函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它。第二个参数指定了顶点数组的起始索引，我们这里填0。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长，6个点则填6）。</p><blockquote><p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。<br>这是不使用索引缓冲对象的时候的绘制方式。</p></blockquote><h4 id="glDrawElements-GL-TRIANGLES-6-GL-UNSIGNED-INT-0"><a href="#glDrawElements-GL-TRIANGLES-6-GL-UNSIGNED-INT-0" class="headerlink" title="glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);"></a>glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</h4><p>用<code>glDrawElements</code>来替换glDrawArrays函数，来指明我们从索引缓冲渲染。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制。</p><p>第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</p><p>glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。这也是为什么我们之前的代码在绘制时候是绑定的VAO。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/1.2/4.png)</center><p> 两个三角形如左。要想用线框模式绘制你的三角形，你可以（在渲染循环）通过glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出渲染循环后</span></span><br><span class="line"><span class="comment">// optional: de-allocate all resources once they&#x27;ve outlived their purpose:</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">glDeleteProgram(shaderProgram);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记1.1-你好，窗口</title>
    <link href="https://idinghy.com/2020/11/29/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.1-%E4%BD%A0%E5%A5%BD%EF%BC%8C%E7%AA%97%E5%8F%A3/"/>
    <id>https://idinghy.com/2020/11/29/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.1-%E4%BD%A0%E5%A5%BD%EF%BC%8C%E7%AA%97%E5%8F%A3/</id>
    <published>2020-11-29T11:51:24.000Z</published>
    <updated>2020-11-29T16:37:29.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><ul><li>官方课程主页见<a href="https://learnopengl-cn.github.io/01%20Getting%20started/03%20Hello%20Window/">这里</a></li><li>官方代码版本见<a href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/1.2.hello_window_clear/hello_window_clear.cpp">这里</a>。</li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>创建一个可以改变大小、退出的窗口</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// glfw: initialize and configure</span></span><br><span class="line">    <span class="comment">// ------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化GLFW</span></span><br><span class="line">    glfwInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用glfwWindowHint函数来配置GLFW(https://www.glfw.org/docs/latest/window.html#window_hints)</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//设置主版本号为3</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//设置次版本号为3</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class="comment">//告诉GLFW我们使用的是核心模式(Core - profile)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __APPLE__</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);<span class="comment">//如果使用的是Mac OS X系统需要加上此行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw window creation</span></span><br><span class="line">    <span class="comment">// --------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个窗口对象</span></span><br><span class="line">    <span class="comment">//glfwCreateWindow函数需要窗口的宽和高作为它的前两个参数。第三个参数表示这个窗口的名称（标题）,最后两个参数我们暂时忽略。返回一个GLFWwindow对象。</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建失败处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通知GLFW将我们窗口的上下文设置为当前线程的主上下文。</span></span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    <span class="comment">//告诉GLFW我们希望每当窗口调整大小的时候调用</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad: load all OpenGL function pointers</span></span><br><span class="line">    <span class="comment">// ---------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//GLAD是用来管理OpenGL的函数指针的，所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line">    <span class="comment">//我们给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数。GLFW给我们的是glfwGetProcAddress，它根据我们编译的系统定义了正确的函数</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render loop:它能在我们让GLFW退出前一直保持运行</span></span><br><span class="line">    <span class="comment">// -----------</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// input</span></span><br><span class="line">        <span class="comment">// -----</span></span><br><span class="line">        processInput(window);<span class="comment">//检测特定的键是否被按下，并在每一帧做出处理。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// render</span></span><br><span class="line">        <span class="comment">// ------</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">//使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);<span class="comment">//清空颜色缓冲</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span></span><br><span class="line">        <span class="comment">// -------------------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);<span class="comment">//交换颜色缓冲（它是一个储存着GLFW窗口每一个像素颜色值的大缓冲），它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwPollEvents();<span class="comment">//检查有没有触发什么事件（比如键盘输入、鼠标移动等）、更新窗口状态，并调用对应的回调函数（可以通过回调方法手动设置）。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfw: terminate, clearing all previously allocated GLFW resources.</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//释放/删除之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow *window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//当用户改变窗口的大小的时候，视口也应该被调整。我们可以对窗口注册一个回调函数(Callback Function)，它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// make sure the viewport matches the new window dimensions; note that width and </span></span><br><span class="line">    <span class="comment">// height will be significantly larger than specified on retina displays.</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL学习笔记1.0-环境搭建</title>
    <link href="https://idinghy.com/2020/11/29/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.0-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://idinghy.com/2020/11/29/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01.0-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-11-29T09:09:29.000Z</published>
    <updated>2020-11-29T12:19:42.356Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="教程说明"><a href="#教程说明" class="headerlink" title="教程说明"></a>教程说明</h1><p>来自<a href="https://learnopengl-cn.github.io/">https://learnopengl-cn.github.io/</a><br>感谢原作者JoeyDeVries和各位中文翻译者提供的优质教程</p><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="Microsoft-Visual-Studio下载"><a href="#Microsoft-Visual-Studio下载" class="headerlink" title="Microsoft Visual Studio下载"></a>Microsoft Visual Studio<a href="https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/">下载</a></h2><p>cn_visual_studio_enterprise_2015_with_update_3_x86_x64_dvd_8923298.iso</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1SsdU0R25Lk6sTedumYIeSw">https://pan.baidu.com/s/1SsdU0R25Lk6sTedumYIeSw</a><br>提取码：dddd </p><p>激活密钥搬运来自<a href="https://blog.csdn.net/yhd0916/article/details/73368826">这里</a>(感恩)<br>专业版：HMGNV-WCYXV-X7G9W-YCX63-B98R2<br>企业版：HM6NR-QXX7C-DFW2Y-8B82K-WTYJV</p></blockquote><ul><li>解压后运行<em>vs_enterprise.exe</em>，</li></ul><h2 id="GLFW下载"><a href="#GLFW下载" class="headerlink" title="GLFW下载"></a>GLFW<a href="https://www.glfw.org/download.html">下载</a></h2><p>下载souce package(<strong>glfw-3.3.2.zip</strong>)<br>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文，定义窗口参数以及处理用户输入。下载源码包之后，将其解压并打开。下载源码包之后，将其解压并打开。我们只需要里面的这些内容：</p><ul><li>编译生成的库(glfw3.lib之后生成)</li><li>include文件夹</li></ul><h2 id="CMAKE-下载"><a href="#CMAKE-下载" class="headerlink" title="CMAKE 下载"></a>CMAKE <a href="https://cmake.org/download/">下载</a></h2><p>下载Windows win32-x86 Installer(<strong>cmake-3.19.1-win32-x86.msi</strong>)<br>CMake是一个工程文件生成工具。用户可以使用预定义好的CMake脚本，根据自己的选择（像是Visual Studio, Code::Blocks, Eclipse）生成不同IDE的工程文件。这允许我们从GLFW源码里创建一个Visual Studio 2015工程文件，之后进行编译。<br>安装好cmake之后，打开cmake-gui</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/1.png)</center><p>CMake需要一个源代码目录和一个存放编译结果的目标文件目录。源代码目录我们选择GLFW的源代码的根目录，然后我们新建一个 build 文件夹，选中作为目标目录。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/2.png)</center>我们接下来需要选择工程的生成器，由于我们使用的是Visual Studio 2015，我们选择 Visual Studio 14 选项（因为Visual Studio 2015的内部版本号是14）。CMake会显示可选的编译选项用来配置最终生成的库。这里我们使用默认设置，并再次点击Configure(设置)按钮保存设置。保存之后，点击Generate(生成)按钮，生成的工程文件会在你的build文件夹中。<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/3.png)</center><p><strong>问题</strong><br><a href="https://stackoverflow.com/questions/43704734/how-to-fix-the-error-windows-sdk-version-8-1-was-not-found">error MSB8036: The Windows SDK version 8.1 was not found.</a></p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/4.png)</center><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在build文件夹里可以找到GLFW.sln文件，用Visual Studio 2015打开。因为CMake已经配置好了项目，所以我们直接点击Build Solution(生成解决方案)按钮，然后编译的库glfw3.lib（注意我们用的是第3版）就会出现在src/Debug文件夹内。</p><p>库生成完毕之后，我们需要让IDE知道库和头文件的位置。有两种方法：</p><ol><li>找到IDE或者编译器的/lib和/include文件夹，添加GLFW的include文件夹里的文件到IDE的/include文件夹里去。用类似的方法，将glfw3.lib添加到/lib文件夹里去。虽然这样能工作，但这不是推荐的方式，因为这样会让你很难去管理库和include文件，而且重新安装IDE或编译器可能会导致这些文件丢失。</li><li>推荐的方式是建立一个新的目录包含所有的第三方库文件和头文件，并且在你的IDE或编译器中指定这些文件夹。我个人会使用一个单独的文件夹，里面包含Libs和Include文件夹，在这里存放OpenGL工程用到的所有第三方库和头文件。这样我的所有第三方库都在同一个位置（并且可以共享至多台电脑）。然而这要求你每次新建一个工程时都需要告诉IDE/编译器在哪能找到这些目录。<br>完成上面步骤后，我们就可以使用GLFW创建我们的第一个OpenGL工程了！</li></ol><p>选择第二种方式：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/5.png)</center><h2 id="建立工程"><a href="#建立工程" class="headerlink" title="建立工程"></a>建立工程</h2><p>首先，打开Visual Studio，创建一个新的项目。如果VS提供了多个选项，选择Visual C++，然后选择Empty Project(空项目)（别忘了给你的项目起一个合适的名字）。现在我们终于有一个空的工作空间了，开始创建我们第一个OpenGL程序吧！</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/6.png)</center><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>为了使我们的程序使用GLFW，我们需要把GLFW库链接(Link)进工程。这可以通过在链接器的设置里指定我们要使用glfw3.lib来完成，但是由于我们将第三方库放在另外的目录中，我们的工程还不知道在哪寻找这个文件。于是我们首先需要将我们放第三方库的目录添加进设置。</p><p>要添加这些目录（需要VS搜索库和include文件的地方），我们首先进入Project Properties(工程属性，在解决方案窗口里右键项目)，然后选择VC++ Directories(VC++ 目录)选项卡（如下图）。在下面的两栏添加目录：</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/7.png)</center>现在VS可以找到所需的所有文件了，最后需要在Linker(链接器)选项卡里的Input(输入)选项卡里添加glfw3.lib和opengl32.lib（我是Windows平台，opengl32.lib已经包含在Microsoft SDK里了，它在Visual Studio安装的时候就默认安装了，我们只需将opengl32.lib直接添加进连接器设置里就行了）<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/8.png)</center>GLFW的安装与配置就到此为止。## GLADGLAD是一个开源的库，它能解决我们上面提到的那个繁琐的问题。GLAD的配置与大多数的开源库有些许的不同，GLAD使用了一个在线服务。在这里我们能够告诉GLAD需要定义的OpenGL版本，并且根据这个版本加载所有相关的OpenGL函数。>因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。幸运的是，有些库能简化此过程，其中GLAD是目前最新，也是最流行的库。打开[GLAD的在线服务](https://glad.dav1d.de/)，将语言(Language)设置为C/C++，在API选项中，选择3.3以上的OpenGL(gl)版本（我们的教程中将使用3.3版本，但更新的版本也能正常工作）。之后将模式(Profile)设置为Core，并且保证生成加载器(Generate a loader)的选项是选中的。现在可以先（暂时）忽略拓展(Extensions)中的内容。都选择完之后，点击生成(Generate)按钮来生成库文件。<center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/9.png)</center><p>GLAD现在应该提供给你了一个zip压缩文件，包含两个头文件目录，和一个glad.c文件。将两个头文件目录（glad和KHR）复制到你的Include文件夹中（或者增加一个额外的项目指向这些目录），并添加glad.c文件到你的工程中。</p><center>![description](https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/10.png)</center><p>经过前面的这些步骤之后，你就应该可以将以下的指令加到你的文件顶部了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt; </span></span></span><br></pre></td></tr></table></figure><br>新建main.cpp,测试输出。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Dinghyt/dlog@1.0/static/image/20201125/11.png" alt="description"></p><p>&lt;/center&gt;<br>点击编译按钮应该不会给你提示任何的错误。</p>]]></content>
    
    
    <summary type="html">本文是个人学习记录，学习建议看教程</summary>
    
    
    
    <category term="Learning" scheme="https://idinghy.com/category/Learning/"/>
    
    
    <category term="OpenGL" scheme="https://idinghy.com/tag/OpenGL/"/>
    
  </entry>
  
</feed>
